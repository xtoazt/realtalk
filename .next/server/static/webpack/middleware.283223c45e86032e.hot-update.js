"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("middleware",{

/***/ "(middleware)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMessageReaction: () => (/* binding */ addMessageReaction),\n/* harmony export */   clearUserFrozen: () => (/* binding */ clearUserFrozen),\n/* harmony export */   createFriendship: () => (/* binding */ createFriendship),\n/* harmony export */   createGroupChat: () => (/* binding */ createGroupChat),\n/* harmony export */   createMessage: () => (/* binding */ createMessage),\n/* harmony export */   createNotification: () => (/* binding */ createNotification),\n/* harmony export */   createUser: () => (/* binding */ createUser),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   deleteGroupChat: () => (/* binding */ deleteGroupChat),\n/* harmony export */   getAcceptedFriends: () => (/* binding */ getAcceptedFriends),\n/* harmony export */   getFriendships: () => (/* binding */ getFriendships),\n/* harmony export */   getMessages: () => (/* binding */ getMessages),\n/* harmony export */   getOnlineUsers: () => (/* binding */ getOnlineUsers),\n/* harmony export */   getUnreadNotifications: () => (/* binding */ getUnreadNotifications),\n/* harmony export */   getUserById: () => (/* binding */ getUserById),\n/* harmony export */   getUserByUsername: () => (/* binding */ getUserByUsername),\n/* harmony export */   getUserDMs: () => (/* binding */ getUserDMs),\n/* harmony export */   getUserFreezeStatus: () => (/* binding */ getUserFreezeStatus),\n/* harmony export */   getUserGroupChats: () => (/* binding */ getUserGroupChats),\n/* harmony export */   markNotificationAsRead: () => (/* binding */ markNotificationAsRead),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   removeMessageReaction: () => (/* binding */ removeMessageReaction),\n/* harmony export */   searchUsers: () => (/* binding */ searchUsers),\n/* harmony export */   setUserFrozen: () => (/* binding */ setUserFrozen),\n/* harmony export */   updateFriendshipStatus: () => (/* binding */ updateFriendshipStatus),\n/* harmony export */   updateUserActivity: () => (/* binding */ updateUserActivity),\n/* harmony export */   updateUserSettings: () => (/* binding */ updateUserSettings)\n/* harmony export */ });\n/* harmony import */ var server_only__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! server-only */ \"(middleware)/./node_modules/.pnpm/next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/server-only/empty.js\");\n/* harmony import */ var server_only__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(server_only__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neondatabase/serverless */ \"(middleware)/./node_modules/.pnpm/@neondatabase+serverless@1.0.1/node_modules/@neondatabase/serverless/index.mjs\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/constants */ \"(middleware)/./lib/constants.ts\");\n\n\n\n// Check if we should use SQLite for local development\nconst databaseUrl = process.env.DATABASE_URL || \"\";\nconst useSQLite = !databaseUrl.includes('postgresql://') || databaseUrl.includes('localhost:5432');\nlet sql;\nif (useSQLite) {\n    // Use in-memory database for local development\n    console.log(\"[db] Using in-memory database for local development\");\n    // Simple in-memory storage\n    const memoryDb = {\n        users: [],\n        messages: [],\n        friendships: [],\n        group_chats: [],\n        group_chat_members: [],\n        notifications: [],\n        message_reactions: [],\n        polls: [],\n        poll_responses: [],\n        poll_shares: [],\n        calendar_events: [],\n        calendar_participants: [],\n        channels: [\n            {\n                id: 'school',\n                name: 'School',\n                creator_id: null,\n                is_system: true,\n                created_at: new Date()\n            },\n            {\n                id: 'unblocked',\n                name: 'Unblocked',\n                creator_id: null,\n                is_system: true,\n                created_at: new Date()\n            },\n            {\n                id: 'random',\n                name: 'Random',\n                creator_id: null,\n                is_system: true,\n                created_at: new Date()\n            }\n        ]\n    };\n    const mockDb = {\n        query: async function(strings, ...values) {\n            const query = strings.join('?').toLowerCase();\n            console.log(\"[db] Mock query:\", query, values);\n            // Handle different query types\n            if (query.includes('select * from users where username')) {\n                const username = values[0];\n                const user = memoryDb.users.find((u)=>u.username === username);\n                return user ? [\n                    user\n                ] : [];\n            }\n            if (query.includes('select * from users where id')) {\n                const id = values[0];\n                return memoryDb.users.filter((u)=>u.id === id);\n            }\n            if (query.includes('insert into users')) {\n                const newUser = {\n                    id: `user-${Date.now()}`,\n                    username: values[0],\n                    password_hash: values[1],\n                    signup_code: values[2] || null,\n                    name_color: values[3] || null,\n                    custom_title: null,\n                    has_gold_animation: values[4] || false,\n                    notifications_enabled: false,\n                    theme: 'light',\n                    hue: 'blue',\n                    profile_picture: null,\n                    bio: null,\n                    ui_mode: 'full',\n                    last_active: new Date(),\n                    is_frozen: false,\n                    frozen_by: null,\n                    freeze_message: null,\n                    freeze_popup_message: null,\n                    freeze_updated_at: new Date(),\n                    created_at: new Date(),\n                    updated_at: new Date()\n                };\n                memoryDb.users.push(newUser);\n                return [\n                    newUser\n                ];\n            }\n            if (query.includes('select * from messages') || query.includes('select m.*, u.username')) {\n                // Return messages with user information\n                return memoryDb.messages.map((msg)=>({\n                        ...msg,\n                        username: 'testuser3',\n                        name_color: null,\n                        custom_title: null,\n                        has_gold_animation: false,\n                        reactions: [],\n                        parent_message_content: null,\n                        parent_message_username: null\n                    }));\n            }\n            if (query.includes('insert into messages')) {\n                const newMessage = {\n                    id: `msg-${Date.now()}`,\n                    sender_id: values[0],\n                    content: values[1],\n                    chat_type: values[2],\n                    chat_id: values[3],\n                    mentions: values[4] || [],\n                    is_ai_response: values[5] || false,\n                    parent_message_id: values[6] || null,\n                    message_type: values[7] || 'text',\n                    created_at: new Date(),\n                    updated_at: new Date()\n                };\n                memoryDb.messages.push(newMessage);\n                return [\n                    newMessage\n                ];\n            }\n            if (query.includes('select * from channels')) {\n                return memoryDb.channels;\n            }\n            if (query.includes('select * from friendships')) {\n                return memoryDb.friendships;\n            }\n            if (query.includes('select * from group_chats')) {\n                return memoryDb.group_chats;\n            }\n            if (query.includes('select * from polls')) {\n                return memoryDb.polls;\n            }\n            if (query.includes('select * from calendar_events')) {\n                return memoryDb.calendar_events;\n            }\n            return [];\n        },\n        unsafe: async function(query, params = []) {\n            console.log(\"[db] Mock unsafe query:\", query, params);\n            return {\n                changes: 0\n            };\n        }\n    };\n    sql = mockDb;\n} else {\n    // Use Neon PostgreSQL\n    try {\n        sql = (0,_neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__.neon)(process.env.DATABASE_URL);\n    } catch (error) {\n        console.error(\"[db] Failed to connect to Neon, falling back to mock:\", error);\n        const mockDb = {\n            async query (strings, ...values) {\n                console.log(\"[db] Mock query:\", strings.join('?'), values);\n                return [];\n            },\n            async unsafe (query, params = []) {\n                console.log(\"[db] Mock unsafe query:\", query, params);\n                return {\n                    changes: 0\n                };\n            }\n        };\n        sql = mockDb;\n    }\n}\n// Create a proper query function that works with template literals\nconst query = (strings, ...values)=>{\n    return sql.query(strings, ...values);\n};\n\nconst db = sql;\n// Database helper functions\nasync function createUser(username, passwordHash, signupCode) {\n    try {\n        let nameColor = null;\n        const customTitle = null;\n        let hasGoldAnimation = false;\n        if (signupCode === \"asdf\") {\n            nameColor = \"#6366f1\";\n        } else if (signupCode === \"qwea\") {\n            hasGoldAnimation = true;\n        }\n        const result = await sql`\n      INSERT INTO users (username, password_hash, signup_code, name_color, has_gold_animation, email, last_active, theme, hue, ui_mode)\n      VALUES (${username}, ${passwordHash}, ${signupCode}, ${nameColor}, ${hasGoldAnimation}, NULL, NOW(), 'light', 'blue', 'full')\n      RETURNING id, username, email, signup_code, name_color, custom_title, has_gold_animation, notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createUser error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserByUsername(username) {\n    try {\n        const rows = await sql`\n      SELECT *\n      FROM users\n      WHERE username = ${username}\n      LIMIT 1\n    `;\n        return rows[0];\n    } catch (err) {\n        console.error(\"[db] getUserByUsername error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserById(id) {\n    try {\n        const result = await sql`\n      SELECT id, username, email, signup_code, name_color, custom_title, has_gold_animation, \n             notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n      FROM users WHERE id = ${id}\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] getUserById error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateUserActivity(userId) {\n    try {\n        await sql`\n      UPDATE users \n      SET last_active = NOW()\n      WHERE id = ${userId}\n    `;\n        return true;\n    } catch (err) {\n        console.error(\"[db] updateUserActivity error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getOnlineUsers(currentUserId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT u.id, u.username, u.name_color, u.has_gold_animation, u.last_active\n      FROM users u\n      JOIN friendships f ON (\n        (f.requester_id = ${currentUserId} AND f.addressee_id = u.id) OR\n        (f.addressee_id = ${currentUserId} AND f.requester_id = u.id)\n      )\n      WHERE u.last_active > NOW() - INTERVAL '10 minutes'\n      AND f.status = 'accepted'\n      AND u.id != ${currentUserId}\n      AND u.id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      ORDER BY u.username\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getOnlineUsers error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function searchUsers(searchQuery, currentUserId) {\n    try {\n        const result = await sql`\n      SELECT id, username, name_color, custom_title, has_gold_animation\n      FROM users \n      WHERE username ILIKE ${`%${searchQuery}%`} \n      AND id != ${currentUserId}\n      AND id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      LIMIT 10\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] searchUsers error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getMessages(chatType, chatId, userId, limit = 50) {\n    try {\n        if (chatType === \"global\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'global'\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else if (chatType === \"dm\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'dm' \n          AND ((m.sender_id = ${userId} AND m.chat_id = ${chatId}) \n               OR (m.sender_id = ${chatId} AND m.chat_id = ${userId}))\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else if (chatType === \"channel\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'channel' AND m.chat_id = ${chatId}\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = ${chatType} AND m.chat_id = ${chatId}\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        }\n    } catch (err) {\n        console.error(\"[db] getMessages error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createMessage(senderId, content, chatType, chatId, mentions = [], isAiResponse = false, parentMessageId, messageType = \"text\") {\n    try {\n        const result = await sql`\n      INSERT INTO messages (sender_id, content, chat_type, chat_id, mentions, is_ai_response, parent_message_id, message_type)\n      VALUES (${senderId}, ${content}, ${chatType}, ${chatId}, ${mentions}, ${isAiResponse}, ${parentMessageId}, ${messageType})\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createMessage error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createGroupChat(name, creatorId, memberIds = []) {\n    try {\n        const result = await sql`\n      INSERT INTO group_chats (name, creator_id)\n      VALUES (${name}, ${creatorId})\n      RETURNING *\n    `;\n        await sql`\n      INSERT INTO group_chat_members (group_chat_id, user_id)\n      VALUES (${result[0].id}, ${creatorId})\n    `;\n        for (const memberId of memberIds){\n            if (memberId !== creatorId) {\n                await sql`\n          INSERT INTO group_chat_members (group_chat_id, user_id)\n          VALUES (${result[0].id}, ${memberId})\n          ON CONFLICT (group_chat_id, user_id) DO NOTHING\n        `;\n            }\n        }\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createGroupChat error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserGroupChats(userId) {\n    try {\n        const result = await sql`\n      SELECT gc.*, u.username as creator_username\n      FROM group_chats gc\n      JOIN group_chat_members gcm ON gc.id = gcm.group_chat_id\n      JOIN users u ON gc.creator_id = u.id\n      WHERE gcm.user_id = ${userId}\n      ORDER BY gc.updated_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUserGroupChats error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function deleteGroupChat(groupId, creatorId) {\n    try {\n        const chat = await sql`SELECT creator_id FROM group_chats WHERE id = ${groupId}`;\n        if (!chat[0] || chat[0].creator_id !== creatorId) {\n            throw new Error(\"Unauthorized to delete this group chat.\");\n        }\n        await sql`BEGIN`;\n        await sql`DELETE FROM messages WHERE chat_type = 'group' AND chat_id = ${groupId}`;\n        await sql`DELETE FROM group_chat_members WHERE group_chat_id = ${groupId}`;\n        await sql`DELETE FROM group_chats WHERE id = ${groupId}`;\n        await sql`COMMIT`;\n        return true;\n    } catch (err) {\n        await sql`ROLLBACK`;\n        console.error(\"[db] deleteGroupChat error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createFriendship(requesterId, addresseeId) {\n    try {\n        if (requesterId === addresseeId) {\n            throw new Error(\"Cannot send friend request to yourself.\");\n        }\n        const existing = await sql`\n      SELECT * FROM friendships\n      WHERE (requester_id = ${requesterId} AND addressee_id = ${addresseeId})\n         OR (requester_id = ${addresseeId} AND addressee_id = ${requesterId})\n      LIMIT 1\n    `;\n        if (existing.length > 0) {\n            if (existing[0].status === \"pending\") {\n                throw new Error(\"Friend request already pending.\");\n            } else if (existing[0].status === \"accepted\") {\n                throw new Error(\"Already friends with this user.\");\n            } else if (existing[0].status === \"blocked\") {\n                throw new Error(\"Cannot send request due to existing block.\");\n            }\n        }\n        const result = await sql`\n      INSERT INTO friendships (requester_id, addressee_id, status)\n      VALUES (${requesterId}, ${addresseeId}, 'pending')\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createFriendship error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateFriendshipStatus(friendshipId, status) {\n    try {\n        const result = await sql`\n      UPDATE friendships \n      SET status = ${status}, updated_at = NOW()\n      WHERE id = ${friendshipId}\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] updateFriendshipStatus error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getFriendships(userId) {\n    try {\n        const result = await sql`\n      SELECT f.*, \n             u1.username as requester_username,\n             u2.username as addressee_username,\n             u1.name_color as requester_name_color,\n             u2.name_color as addressee_name_color,\n             u1.has_gold_animation as requester_has_gold,\n             u2.has_gold_animation as addressee_has_gold\n      FROM friendships f\n      JOIN users u1 ON f.requester_id = u1.id\n      JOIN users u2 ON f.addressee_id = u2.id\n      WHERE (f.requester_id = ${userId} OR f.addressee_id = ${userId})\n      ORDER BY f.created_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getFriendships error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getAcceptedFriends(userId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.id\n          ELSE u1.id\n        END as friend_id,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.username\n          ELSE u1.username\n        END as friend_username,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.name_color\n          ELSE u1.name_color\n        END as friend_name_color,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.has_gold_animation\n          ELSE u1.has_gold_animation\n        END as friend_has_gold\n      FROM friendships f\n      JOIN users u1 ON f.requester_id = u1.id\n      JOIN users u2 ON f.addressee_id = u2.id\n      WHERE (f.requester_id = ${userId} OR f.addressee_id = ${userId})\n      AND f.status = 'accepted'\n      ORDER BY friend_username\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getAcceptedFriends error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserDMs(userId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT\n        CASE\n          WHEN m.sender_id = ${userId} THEN m.chat_id\n          ELSE m.sender_id\n        END as friend_id,\n        u.username as friend_username,\n        u.name_color as friend_name_color,\n        u.has_gold_animation as friend_has_gold,\n        MAX(m.created_at) as last_message_at\n      FROM messages m\n      JOIN users u ON \n        CASE\n          WHEN m.sender_id = ${userId} THEN m.chat_id\n          ELSE m.sender_id\n        END = u.id\n      WHERE m.chat_type = 'dm' \n      AND (m.sender_id = ${userId} OR m.chat_id = ${userId})\n      AND u.id != ${userId}\n      AND u.id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      GROUP BY friend_id, u.username, u.name_color, u.has_gold_animation\n      ORDER BY last_message_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUserDMs error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createNotification(userId, title, message, chatType, chatId, senderUsername) {\n    try {\n        const result = await sql`\n      INSERT INTO notifications (user_id, title, message, chat_type, chat_id, sender_username)\n      VALUES (${userId}, ${title}, ${message}, ${chatType}, ${chatId}, ${senderUsername})\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createNotification error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUnreadNotifications(userId) {\n    try {\n        const result = await sql`\n      SELECT * FROM notifications\n      WHERE user_id = ${userId} AND is_read = FALSE\n      ORDER BY created_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUnreadNotifications error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function markNotificationAsRead(notificationId, userId) {\n    try {\n        const result = await sql`\n      UPDATE notifications\n      SET is_read = TRUE, created_at = NOW()\n      WHERE id = ${notificationId} AND user_id = ${userId}\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] markNotificationAsRead error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function addMessageReaction(messageId, userId, emoji) {\n    try {\n        const result = await sql`\n      INSERT INTO message_reactions (message_id, user_id, emoji)\n      VALUES (${messageId}, ${userId}, ${emoji})\n      ON CONFLICT (message_id, user_id, emoji) DO NOTHING\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] addMessageReaction error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function removeMessageReaction(messageId, userId, emoji) {\n    try {\n        await sql`\n      DELETE FROM message_reactions\n      WHERE message_id = ${messageId}\n        AND user_id   = ${userId}\n        AND emoji     = ${emoji}\n    `;\n        return true;\n    } catch (err) {\n        console.error(\"[db] removeMessageReaction error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateUserSettings(userId, updates) {\n    try {\n        const allowedFields = [\n            \"name_color\",\n            \"notifications_enabled\",\n            \"theme\",\n            \"hue\",\n            \"ui_mode\"\n        ];\n        const validUpdates = {};\n        for (const [key, value] of Object.entries(updates)){\n            if (allowedFields.includes(key)) {\n                validUpdates[key] = value;\n            }\n        }\n        if (Object.keys(validUpdates).length === 0) {\n            throw new Error(\"No valid fields to update\");\n        }\n        const setClause = Object.keys(validUpdates).map((key, index)=>`${key} = $${index + 2}`).join(\", \");\n        const queryString = `\n      UPDATE users \n      SET ${setClause}, updated_at = NOW()\n      WHERE id = $1\n      RETURNING id, username, email, signup_code, name_color, custom_title, has_gold_animation, notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n    `;\n        const params = [\n            userId,\n            ...Object.values(validUpdates)\n        ];\n        const result = await sql.unsafe(queryString, params);\n        if (!result || result.length === 0) {\n            throw new Error(\"User not found or no settings updated.\");\n        }\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] updateUserSettings error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\n// Freeze feature\nasync function setUserFrozen(targetUserId, frozenByUserId, message) {\n    try {\n        const result = await sql`\n      UPDATE users\n      SET is_frozen = TRUE, frozen_by = ${frozenByUserId}, freeze_message = ${message || null}, updated_at = NOW()\n      WHERE id = ${targetUserId}\n      RETURNING id, is_frozen, frozen_by, freeze_message\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] setUserFrozen error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function clearUserFrozen(targetUserId) {\n    try {\n        const result = await sql`\n      UPDATE users\n      SET is_frozen = FALSE, frozen_by = NULL, freeze_message = NULL, updated_at = NOW()\n      WHERE id = ${targetUserId}\n      RETURNING id, is_frozen, frozen_by, freeze_message\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] clearUserFrozen error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserFreezeStatus(userId) {\n    try {\n        const result = await sql`\n      SELECT is_frozen, frozen_by, freeze_message FROM users WHERE id = ${userId}\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] getUserFreezeStatus error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUssQ0FBQywrQkFBK0JTO1FBQzdDLE1BQU0sSUFBSUMsTUFBTSxxQkFBcUIsSUFBZUMsT0FBTztJQUM3RDtBQUNGO0FBRU8sZUFBZWlFLG9CQUFvQjVELE1BQWM7SUFDdEQsSUFBSTtRQUNGLE1BQU1SLFNBQVMsTUFBTWhGLEdBQUcsQ0FBQzt3RUFDMkMsRUFBRXdGLE9BQU87SUFDN0UsQ0FBQztRQUNELE9BQU9SLE1BQU0sQ0FBQyxFQUFFO0lBQ2xCLEVBQUUsT0FBT0MsS0FBSztRQUNaaEYsUUFBUXVFLEtBQUssQ0FBQyxtQ0FBbUNTO1FBQ2pELE1BQU0sSUFBSUMsTUFBTSxxQkFBcUIsSUFBZUMsT0FBTztJQUM3RDtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvcm9oYW4vY29kZS9yZWFsdGFsay9saWIvZGIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwic2VydmVyLW9ubHlcIlxuaW1wb3J0IHsgbmVvbiB9IGZyb20gXCJAbmVvbmRhdGFiYXNlL3NlcnZlcmxlc3NcIlxuaW1wb3J0IHsgQUlfVVNFUl9JRCB9IGZyb20gXCJAL2xpYi9jb25zdGFudHNcIlxuXG4vLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIFNRTGl0ZSBmb3IgbG9jYWwgZGV2ZWxvcG1lbnRcbmNvbnN0IGRhdGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMIHx8IFwiXCJcbmNvbnN0IHVzZVNRTGl0ZSA9ICFkYXRhYmFzZVVybC5pbmNsdWRlcygncG9zdGdyZXNxbDovLycpIHx8IGRhdGFiYXNlVXJsLmluY2x1ZGVzKCdsb2NhbGhvc3Q6NTQzMicpXG5cbmxldCBzcWw6IGFueVxuXG5pZiAodXNlU1FMaXRlKSB7XG4gIC8vIFVzZSBpbi1tZW1vcnkgZGF0YWJhc2UgZm9yIGxvY2FsIGRldmVsb3BtZW50XG4gIGNvbnNvbGUubG9nKFwiW2RiXSBVc2luZyBpbi1tZW1vcnkgZGF0YWJhc2UgZm9yIGxvY2FsIGRldmVsb3BtZW50XCIpXG4gIFxuICAvLyBTaW1wbGUgaW4tbWVtb3J5IHN0b3JhZ2VcbiAgY29uc3QgbWVtb3J5RGI6IGFueSA9IHtcbiAgICB1c2VyczogW10sXG4gICAgbWVzc2FnZXM6IFtdLFxuICAgIGZyaWVuZHNoaXBzOiBbXSxcbiAgICBncm91cF9jaGF0czogW10sXG4gICAgZ3JvdXBfY2hhdF9tZW1iZXJzOiBbXSxcbiAgICBub3RpZmljYXRpb25zOiBbXSxcbiAgICBtZXNzYWdlX3JlYWN0aW9uczogW10sXG4gICAgcG9sbHM6IFtdLFxuICAgIHBvbGxfcmVzcG9uc2VzOiBbXSxcbiAgICBwb2xsX3NoYXJlczogW10sXG4gICAgY2FsZW5kYXJfZXZlbnRzOiBbXSxcbiAgICBjYWxlbmRhcl9wYXJ0aWNpcGFudHM6IFtdLFxuICAgIGNoYW5uZWxzOiBbXG4gICAgICB7IGlkOiAnc2Nob29sJywgbmFtZTogJ1NjaG9vbCcsIGNyZWF0b3JfaWQ6IG51bGwsIGlzX3N5c3RlbTogdHJ1ZSwgY3JlYXRlZF9hdDogbmV3IERhdGUoKSB9LFxuICAgICAgeyBpZDogJ3VuYmxvY2tlZCcsIG5hbWU6ICdVbmJsb2NrZWQnLCBjcmVhdG9yX2lkOiBudWxsLCBpc19zeXN0ZW06IHRydWUsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkgfSxcbiAgICAgIHsgaWQ6ICdyYW5kb20nLCBuYW1lOiAnUmFuZG9tJywgY3JlYXRvcl9pZDogbnVsbCwgaXNfc3lzdGVtOiB0cnVlLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpIH1cbiAgICBdXG4gIH1cbiAgXG4gIGNvbnN0IG1vY2tEYiA9IHtcbiAgICBxdWVyeTogYXN5bmMgZnVuY3Rpb24oc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnZhbHVlczogYW55W10pIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gc3RyaW5ncy5qb2luKCc/JykudG9Mb3dlckNhc2UoKVxuICAgICAgY29uc29sZS5sb2coXCJbZGJdIE1vY2sgcXVlcnk6XCIsIHF1ZXJ5LCB2YWx1ZXMpXG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcXVlcnkgdHlwZXNcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnc2VsZWN0ICogZnJvbSB1c2VycyB3aGVyZSB1c2VybmFtZScpKSB7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gdmFsdWVzWzBdXG4gICAgICAgIGNvbnN0IHVzZXIgPSBtZW1vcnlEYi51c2Vycy5maW5kKCh1OiBhbnkpID0+IHUudXNlcm5hbWUgPT09IHVzZXJuYW1lKVxuICAgICAgICByZXR1cm4gdXNlciA/IFt1c2VyXSA6IFtdXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnc2VsZWN0ICogZnJvbSB1c2VycyB3aGVyZSBpZCcpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdmFsdWVzWzBdXG4gICAgICAgIHJldHVybiBtZW1vcnlEYi51c2Vycy5maWx0ZXIoKHU6IGFueSkgPT4gdS5pZCA9PT0gaWQpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnaW5zZXJ0IGludG8gdXNlcnMnKSkge1xuICAgICAgICBjb25zdCBuZXdVc2VyID0ge1xuICAgICAgICAgIGlkOiBgdXNlci0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICB1c2VybmFtZTogdmFsdWVzWzBdLFxuICAgICAgICAgIHBhc3N3b3JkX2hhc2g6IHZhbHVlc1sxXSxcbiAgICAgICAgICBzaWdudXBfY29kZTogdmFsdWVzWzJdIHx8IG51bGwsXG4gICAgICAgICAgbmFtZV9jb2xvcjogdmFsdWVzWzNdIHx8IG51bGwsXG4gICAgICAgICAgY3VzdG9tX3RpdGxlOiBudWxsLFxuICAgICAgICAgIGhhc19nb2xkX2FuaW1hdGlvbjogdmFsdWVzWzRdIHx8IGZhbHNlLFxuICAgICAgICAgIG5vdGlmaWNhdGlvbnNfZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgICAgaHVlOiAnYmx1ZScsXG4gICAgICAgICAgcHJvZmlsZV9waWN0dXJlOiBudWxsLFxuICAgICAgICAgIGJpbzogbnVsbCxcbiAgICAgICAgICB1aV9tb2RlOiAnZnVsbCcsXG4gICAgICAgICAgbGFzdF9hY3RpdmU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgaXNfZnJvemVuOiBmYWxzZSxcbiAgICAgICAgICBmcm96ZW5fYnk6IG51bGwsXG4gICAgICAgICAgZnJlZXplX21lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgZnJlZXplX3BvcHVwX21lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgZnJlZXplX3VwZGF0ZWRfYXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgICAgbWVtb3J5RGIudXNlcnMucHVzaChuZXdVc2VyKVxuICAgICAgICByZXR1cm4gW25ld1VzZXJdXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnc2VsZWN0ICogZnJvbSBtZXNzYWdlcycpIHx8IHF1ZXJ5LmluY2x1ZGVzKCdzZWxlY3QgbS4qLCB1LnVzZXJuYW1lJykpIHtcbiAgICAgICAgLy8gUmV0dXJuIG1lc3NhZ2VzIHdpdGggdXNlciBpbmZvcm1hdGlvblxuICAgICAgICByZXR1cm4gbWVtb3J5RGIubWVzc2FnZXMubWFwKChtc2c6IGFueSkgPT4gKHtcbiAgICAgICAgICAuLi5tc2csXG4gICAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcjMnLCAvLyBNb2NrIHVzZXJuYW1lXG4gICAgICAgICAgbmFtZV9jb2xvcjogbnVsbCxcbiAgICAgICAgICBjdXN0b21fdGl0bGU6IG51bGwsXG4gICAgICAgICAgaGFzX2dvbGRfYW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICByZWFjdGlvbnM6IFtdLFxuICAgICAgICAgIHBhcmVudF9tZXNzYWdlX2NvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgcGFyZW50X21lc3NhZ2VfdXNlcm5hbWU6IG51bGxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnaW5zZXJ0IGludG8gbWVzc2FnZXMnKSkge1xuICAgICAgICBjb25zdCBuZXdNZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBgbXNnLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgIHNlbmRlcl9pZDogdmFsdWVzWzBdLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlc1sxXSxcbiAgICAgICAgICBjaGF0X3R5cGU6IHZhbHVlc1syXSxcbiAgICAgICAgICBjaGF0X2lkOiB2YWx1ZXNbM10sXG4gICAgICAgICAgbWVudGlvbnM6IHZhbHVlc1s0XSB8fCBbXSxcbiAgICAgICAgICBpc19haV9yZXNwb25zZTogdmFsdWVzWzVdIHx8IGZhbHNlLFxuICAgICAgICAgIHBhcmVudF9tZXNzYWdlX2lkOiB2YWx1ZXNbNl0gfHwgbnVsbCxcbiAgICAgICAgICBtZXNzYWdlX3R5cGU6IHZhbHVlc1s3XSB8fCAndGV4dCcsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgICAgbWVtb3J5RGIubWVzc2FnZXMucHVzaChuZXdNZXNzYWdlKVxuICAgICAgICByZXR1cm4gW25ld01lc3NhZ2VdXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnc2VsZWN0ICogZnJvbSBjaGFubmVscycpKSB7XG4gICAgICAgIHJldHVybiBtZW1vcnlEYi5jaGFubmVsc1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocXVlcnkuaW5jbHVkZXMoJ3NlbGVjdCAqIGZyb20gZnJpZW5kc2hpcHMnKSkge1xuICAgICAgICByZXR1cm4gbWVtb3J5RGIuZnJpZW5kc2hpcHNcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5LmluY2x1ZGVzKCdzZWxlY3QgKiBmcm9tIGdyb3VwX2NoYXRzJykpIHtcbiAgICAgICAgcmV0dXJuIG1lbW9yeURiLmdyb3VwX2NoYXRzXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlcygnc2VsZWN0ICogZnJvbSBwb2xscycpKSB7XG4gICAgICAgIHJldHVybiBtZW1vcnlEYi5wb2xsc1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocXVlcnkuaW5jbHVkZXMoJ3NlbGVjdCAqIGZyb20gY2FsZW5kYXJfZXZlbnRzJykpIHtcbiAgICAgICAgcmV0dXJuIG1lbW9yeURiLmNhbGVuZGFyX2V2ZW50c1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gW11cbiAgICB9LFxuICAgIFxuICAgIHVuc2FmZTogYXN5bmMgZnVuY3Rpb24ocXVlcnk6IHN0cmluZywgcGFyYW1zOiBhbnlbXSA9IFtdKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltkYl0gTW9jayB1bnNhZmUgcXVlcnk6XCIsIHF1ZXJ5LCBwYXJhbXMpXG4gICAgICByZXR1cm4geyBjaGFuZ2VzOiAwIH1cbiAgICB9XG4gIH1cbiAgXG4gIHNxbCA9IG1vY2tEYlxufSBlbHNlIHtcbiAgLy8gVXNlIE5lb24gUG9zdGdyZVNRTFxuICB0cnkge1xuICAgIHNxbCA9IG5lb24ocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMISlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBGYWlsZWQgdG8gY29ubmVjdCB0byBOZW9uLCBmYWxsaW5nIGJhY2sgdG8gbW9jazpcIiwgZXJyb3IpXG4gICAgY29uc3QgbW9ja0RiID0ge1xuICAgICAgYXN5bmMgcXVlcnkoc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnZhbHVlczogYW55W10pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbZGJdIE1vY2sgcXVlcnk6XCIsIHN0cmluZ3Muam9pbignPycpLCB2YWx1ZXMpXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHVuc2FmZShxdWVyeTogc3RyaW5nLCBwYXJhbXM6IGFueVtdID0gW10pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbZGJdIE1vY2sgdW5zYWZlIHF1ZXJ5OlwiLCBxdWVyeSwgcGFyYW1zKVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiAwIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3FsID0gbW9ja0RiXG4gIH1cbn1cblxuLy8gQ3JlYXRlIGEgcHJvcGVyIHF1ZXJ5IGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCB0ZW1wbGF0ZSBsaXRlcmFsc1xuY29uc3QgcXVlcnkgPSAoc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnZhbHVlczogYW55W10pID0+IHtcbiAgcmV0dXJuIHNxbC5xdWVyeShzdHJpbmdzLCAuLi52YWx1ZXMpXG59XG5cbmV4cG9ydCB7IHF1ZXJ5IH1cbmV4cG9ydCBjb25zdCBkYiA9IHNxbFxuXG4vLyBEYXRhYmFzZSBoZWxwZXIgZnVuY3Rpb25zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZEhhc2g6IHN0cmluZywgc2lnbnVwQ29kZT86IHN0cmluZykge1xuICB0cnkge1xuICAgIGxldCBuYW1lQ29sb3IgPSBudWxsXG4gICAgY29uc3QgY3VzdG9tVGl0bGUgPSBudWxsXG4gICAgbGV0IGhhc0dvbGRBbmltYXRpb24gPSBmYWxzZVxuXG4gICAgaWYgKHNpZ251cENvZGUgPT09IFwiYXNkZlwiKSB7XG4gICAgICBuYW1lQ29sb3IgPSBcIiM2MzY2ZjFcIlxuICAgIH0gZWxzZSBpZiAoc2lnbnVwQ29kZSA9PT0gXCJxd2VhXCIpIHtcbiAgICAgIGhhc0dvbGRBbmltYXRpb24gPSB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gdXNlcnMgKHVzZXJuYW1lLCBwYXNzd29yZF9oYXNoLCBzaWdudXBfY29kZSwgbmFtZV9jb2xvciwgaGFzX2dvbGRfYW5pbWF0aW9uLCBlbWFpbCwgbGFzdF9hY3RpdmUsIHRoZW1lLCBodWUsIHVpX21vZGUpXG4gICAgICBWQUxVRVMgKCR7dXNlcm5hbWV9LCAke3Bhc3N3b3JkSGFzaH0sICR7c2lnbnVwQ29kZX0sICR7bmFtZUNvbG9yfSwgJHtoYXNHb2xkQW5pbWF0aW9ufSwgTlVMTCwgTk9XKCksICdsaWdodCcsICdibHVlJywgJ2Z1bGwnKVxuICAgICAgUkVUVVJOSU5HIGlkLCB1c2VybmFtZSwgZW1haWwsIHNpZ251cF9jb2RlLCBuYW1lX2NvbG9yLCBjdXN0b21fdGl0bGUsIGhhc19nb2xkX2FuaW1hdGlvbiwgbm90aWZpY2F0aW9uc19lbmFibGVkLCB0aGVtZSwgaHVlLCBwcm9maWxlX3BpY3R1cmUsIGJpbywgdWlfbW9kZVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGNyZWF0ZVVzZXIgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyQnlVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgcm93cyA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIHVzZXJzXG4gICAgICBXSEVSRSB1c2VybmFtZSA9ICR7dXNlcm5hbWV9XG4gICAgICBMSU1JVCAxXG4gICAgYFxuICAgIHJldHVybiByb3dzWzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFVzZXJCeVVzZXJuYW1lIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckJ5SWQoaWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBpZCwgdXNlcm5hbWUsIGVtYWlsLCBzaWdudXBfY29kZSwgbmFtZV9jb2xvciwgY3VzdG9tX3RpdGxlLCBoYXNfZ29sZF9hbmltYXRpb24sIFxuICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNfZW5hYmxlZCwgdGhlbWUsIGh1ZSwgcHJvZmlsZV9waWN0dXJlLCBiaW8sIHVpX21vZGVcbiAgICAgIEZST00gdXNlcnMgV0hFUkUgaWQgPSAke2lkfVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFVzZXJCeUlkIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlckFjdGl2aXR5KHVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgc3FsYFxuICAgICAgVVBEQVRFIHVzZXJzIFxuICAgICAgU0VUIGxhc3RfYWN0aXZlID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHt1c2VySWR9XG4gICAgYFxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIHVwZGF0ZVVzZXJBY3Rpdml0eSBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9ubGluZVVzZXJzKGN1cnJlbnRVc2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBESVNUSU5DVCB1LmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLCB1Lmxhc3RfYWN0aXZlXG4gICAgICBGUk9NIHVzZXJzIHVcbiAgICAgIEpPSU4gZnJpZW5kc2hpcHMgZiBPTiAoXG4gICAgICAgIChmLnJlcXVlc3Rlcl9pZCA9ICR7Y3VycmVudFVzZXJJZH0gQU5EIGYuYWRkcmVzc2VlX2lkID0gdS5pZCkgT1JcbiAgICAgICAgKGYuYWRkcmVzc2VlX2lkID0gJHtjdXJyZW50VXNlcklkfSBBTkQgZi5yZXF1ZXN0ZXJfaWQgPSB1LmlkKVxuICAgICAgKVxuICAgICAgV0hFUkUgdS5sYXN0X2FjdGl2ZSA+IE5PVygpIC0gSU5URVJWQUwgJzEwIG1pbnV0ZXMnXG4gICAgICBBTkQgZi5zdGF0dXMgPSAnYWNjZXB0ZWQnXG4gICAgICBBTkQgdS5pZCAhPSAke2N1cnJlbnRVc2VySWR9XG4gICAgICBBTkQgdS5pZCAhPSAke0FJX1VTRVJfSUR9XG4gICAgICBPUkRFUiBCWSB1LnVzZXJuYW1lXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0T25saW5lVXNlcnMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hVc2VycyhzZWFyY2hRdWVyeTogc3RyaW5nLCBjdXJyZW50VXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgaWQsIHVzZXJuYW1lLCBuYW1lX2NvbG9yLCBjdXN0b21fdGl0bGUsIGhhc19nb2xkX2FuaW1hdGlvblxuICAgICAgRlJPTSB1c2VycyBcbiAgICAgIFdIRVJFIHVzZXJuYW1lIElMSUtFICR7YCUke3NlYXJjaFF1ZXJ5fSVgfSBcbiAgICAgIEFORCBpZCAhPSAke2N1cnJlbnRVc2VySWR9XG4gICAgICBBTkQgaWQgIT0gJHtBSV9VU0VSX0lEfVxuICAgICAgTElNSVQgMTBcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBzZWFyY2hVc2VycyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lc3NhZ2VzKGNoYXRUeXBlOiBzdHJpbmcsIGNoYXRJZD86IHN0cmluZywgdXNlcklkPzogc3RyaW5nLCBsaW1pdCA9IDUwKSB7XG4gIHRyeSB7XG4gICAgaWYgKGNoYXRUeXBlID09PSBcImdsb2JhbFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICAgIFNFTEVDVCBtLiosIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgQ09BTEVTQ0UoXG4gICAgICAgICAgICAgICAgIGpzb25fYWdnKFxuICAgICAgICAgICAgICAgICAgIGpzb25fYnVpbGRfb2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgJ2Vtb2ppJywgbXIuZW1vamksXG4gICAgICAgICAgICAgICAgICAgICAnY291bnQnLCBtci5yZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICdyZWFjdGVkX2J5X21lJywgQ0FTRSBXSEVOIG1yLnVzZXJfcmVhY3RlZCBUSEVOIHRydWUgRUxTRSBmYWxzZSBFTkRcbiAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICkgRklMVEVSIChXSEVSRSBtci5lbW9qaSBJUyBOT1QgTlVMTCksIFxuICAgICAgICAgICAgICAgICAnW10nOjpqc29uXG4gICAgICAgICAgICAgICApIGFzIHJlYWN0aW9ucyxcbiAgICAgICAgICAgICAgIHBtLmNvbnRlbnQgQVMgcGFyZW50X21lc3NhZ2VfY29udGVudCxcbiAgICAgICAgICAgICAgIHB1LnVzZXJuYW1lIEFTIHBhcmVudF9tZXNzYWdlX3VzZXJuYW1lXG4gICAgICAgIEZST00gbWVzc2FnZXMgbVxuICAgICAgICBKT0lOIHVzZXJzIHUgT04gbS5zZW5kZXJfaWQgPSB1LmlkXG4gICAgICAgIExFRlQgSk9JTiAoXG4gICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgQ09VTlQoKikgYXMgcmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICBCT09MX09SKHVzZXJfaWQgPSAke3VzZXJJZCB8fCBudWxsfSkgYXMgdXNlcl9yZWFjdGVkXG4gICAgICAgICAgRlJPTSBtZXNzYWdlX3JlYWN0aW9uc1xuICAgICAgICAgIEdST1VQIEJZIG1lc3NhZ2VfaWQsIGVtb2ppXG4gICAgICAgICkgbXIgT04gbS5pZCA9IG1yLm1lc3NhZ2VfaWRcbiAgICAgICAgTEVGVCBKT0lOIG1lc3NhZ2VzIHBtIE9OIG0ucGFyZW50X21lc3NhZ2VfaWQgPSBwbS5pZFxuICAgICAgICBMRUZUIEpPSU4gdXNlcnMgcHUgT04gcG0uc2VuZGVyX2lkID0gcHUuaWRcbiAgICAgICAgV0hFUkUgbS5jaGF0X3R5cGUgPSAnZ2xvYmFsJ1xuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfSBlbHNlIGlmIChjaGF0VHlwZSA9PT0gXCJkbVwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICAgIFNFTEVDVCBtLiosIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgQ09BTEVTQ0UoXG4gICAgICAgICAgICAgICAgIGpzb25fYWdnKFxuICAgICAgICAgICAgICAgICAgIGpzb25fYnVpbGRfb2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgJ2Vtb2ppJywgbXIuZW1vamksXG4gICAgICAgICAgICAgICAgICAgICAnY291bnQnLCBtci5yZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICdyZWFjdGVkX2J5X21lJywgQ0FTRSBXSEVOIG1yLnVzZXJfcmVhY3RlZCBUSEVOIHRydWUgRUxTRSBmYWxzZSBFTkRcbiAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICkgRklMVEVSIChXSEVSRSBtci5lbW9qaSBJUyBOT1QgTlVMTCksIFxuICAgICAgICAgICAgICAgICAnW10nOjpqc29uXG4gICAgICAgICAgICAgICApIGFzIHJlYWN0aW9ucyxcbiAgICAgICAgICAgICAgIHBtLmNvbnRlbnQgQVMgcGFyZW50X21lc3NhZ2VfY29udGVudCxcbiAgICAgICAgICAgICAgIHB1LnVzZXJuYW1lIEFTIHBhcmVudF9tZXNzYWdlX3VzZXJuYW1lXG4gICAgICAgIEZST00gbWVzc2FnZXMgbVxuICAgICAgICBKT0lOIHVzZXJzIHUgT04gbS5zZW5kZXJfaWQgPSB1LmlkXG4gICAgICAgIExFRlQgSk9JTiAoXG4gICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgQ09VTlQoKikgYXMgcmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICBCT09MX09SKHVzZXJfaWQgPSAke3VzZXJJZCB8fCBudWxsfSkgYXMgdXNlcl9yZWFjdGVkXG4gICAgICAgICAgRlJPTSBtZXNzYWdlX3JlYWN0aW9uc1xuICAgICAgICAgIEdST1VQIEJZIG1lc3NhZ2VfaWQsIGVtb2ppXG4gICAgICAgICkgbXIgT04gbS5pZCA9IG1yLm1lc3NhZ2VfaWRcbiAgICAgICAgTEVGVCBKT0lOIG1lc3NhZ2VzIHBtIE9OIG0ucGFyZW50X21lc3NhZ2VfaWQgPSBwbS5pZFxuICAgICAgICBMRUZUIEpPSU4gdXNlcnMgcHUgT04gcG0uc2VuZGVyX2lkID0gcHUuaWRcbiAgICAgICAgV0hFUkUgbS5jaGF0X3R5cGUgPSAnZG0nIFxuICAgICAgICAgIEFORCAoKG0uc2VuZGVyX2lkID0gJHt1c2VySWR9IEFORCBtLmNoYXRfaWQgPSAke2NoYXRJZH0pIFxuICAgICAgICAgICAgICAgT1IgKG0uc2VuZGVyX2lkID0gJHtjaGF0SWR9IEFORCBtLmNoYXRfaWQgPSAke3VzZXJJZH0pKVxuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfSBlbHNlIGlmIChjaGF0VHlwZSA9PT0gXCJjaGFubmVsXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgICAgU0VMRUNUIG0uKiwgdS51c2VybmFtZSwgdS5uYW1lX2NvbG9yLCB1LmN1c3RvbV90aXRsZSwgdS5oYXNfZ29sZF9hbmltYXRpb24sXG4gICAgICAgICAgICAgICBDT0FMRVNDRShcbiAgICAgICAgICAgICAgICAganNvbl9hZ2coXG4gICAgICAgICAgICAgICAgICAganNvbl9idWlsZF9vYmplY3QoXG4gICAgICAgICAgICAgICAgICAgICAnZW1vamknLCBtci5lbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgICdjb3VudCcsIG1yLnJlYWN0aW9uX2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgJ3JlYWN0ZWRfYnlfbWUnLCBDQVNFIFdIRU4gbXIudXNlcl9yZWFjdGVkIFRIRU4gdHJ1ZSBFTFNFIGZhbHNlIEVORFxuICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgKSBGSUxURVIgKFdIRVJFIG1yLmVtb2ppIElTIE5PVCBOVUxMKSwgXG4gICAgICAgICAgICAgICAgICdbXSc6Ompzb25cbiAgICAgICAgICAgICAgICkgYXMgcmVhY3Rpb25zLFxuICAgICAgICAgICAgICAgcG0uY29udGVudCBBUyBwYXJlbnRfbWVzc2FnZV9jb250ZW50LFxuICAgICAgICAgICAgICAgcHUudXNlcm5hbWUgQVMgcGFyZW50X21lc3NhZ2VfdXNlcm5hbWVcbiAgICAgICAgRlJPTSBtZXNzYWdlcyBtXG4gICAgICAgIEpPSU4gdXNlcnMgdSBPTiBtLnNlbmRlcl9pZCA9IHUuaWRcbiAgICAgICAgTEVGVCBKT0lOIChcbiAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICBDT1VOVCgqKSBhcyByZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgIEJPT0xfT1IodXNlcl9pZCA9ICR7dXNlcklkIHx8IG51bGx9KSBhcyB1c2VyX3JlYWN0ZWRcbiAgICAgICAgICBGUk9NIG1lc3NhZ2VfcmVhY3Rpb25zXG4gICAgICAgICAgR1JPVVAgQlkgbWVzc2FnZV9pZCwgZW1vamlcbiAgICAgICAgKSBtciBPTiBtLmlkID0gbXIubWVzc2FnZV9pZFxuICAgICAgICBMRUZUIEpPSU4gbWVzc2FnZXMgcG0gT04gbS5wYXJlbnRfbWVzc2FnZV9pZCA9IHBtLmlkXG4gICAgICAgIExFRlQgSk9JTiB1c2VycyBwdSBPTiBwbS5zZW5kZXJfaWQgPSBwdS5pZFxuICAgICAgICBXSEVSRSBtLmNoYXRfdHlwZSA9ICdjaGFubmVsJyBBTkQgbS5jaGF0X2lkID0gJHtjaGF0SWR9XG4gICAgICAgIEdST1VQIEJZIG0uaWQsIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLCBwbS5jb250ZW50LCBwdS51c2VybmFtZVxuICAgICAgICBPUkRFUiBCWSBtLmNyZWF0ZWRfYXQgREVTQ1xuICAgICAgICBMSU1JVCAke2xpbWl0fVxuICAgICAgYFxuICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgICBTRUxFQ1QgbS4qLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbixcbiAgICAgICAgICAgICAgIENPQUxFU0NFKFxuICAgICAgICAgICAgICAgICBqc29uX2FnZyhcbiAgICAgICAgICAgICAgICAgICBqc29uX2J1aWxkX29iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICdlbW9qaScsIG1yLmVtb2ppLFxuICAgICAgICAgICAgICAgICAgICAgJ2NvdW50JywgbXIucmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAncmVhY3RlZF9ieV9tZScsIENBU0UgV0hFTiBtci51c2VyX3JlYWN0ZWQgVEhFTiB0cnVlIEVMU0UgZmFsc2UgRU5EXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICApIEZJTFRFUiAoV0hFUkUgbXIuZW1vamkgSVMgTk9UIE5VTEwpLCBcbiAgICAgICAgICAgICAgICAgJ1tdJzo6anNvblxuICAgICAgICAgICAgICAgKSBhcyByZWFjdGlvbnMsXG4gICAgICAgICAgICAgICBwbS5jb250ZW50IEFTIHBhcmVudF9tZXNzYWdlX2NvbnRlbnQsXG4gICAgICAgICAgICAgICBwdS51c2VybmFtZSBBUyBwYXJlbnRfbWVzc2FnZV91c2VybmFtZVxuICAgICAgICBGUk9NIG1lc3NhZ2VzIG1cbiAgICAgICAgSk9JTiB1c2VycyB1IE9OIG0uc2VuZGVyX2lkID0gdS5pZFxuICAgICAgICBMRUZUIEpPSU4gKFxuICAgICAgICAgIFNFTEVDVCBcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgIENPVU5UKCopIGFzIHJlYWN0aW9uX2NvdW50LFxuICAgICAgICAgICAgQk9PTF9PUih1c2VyX2lkID0gJHt1c2VySWQgfHwgbnVsbH0pIGFzIHVzZXJfcmVhY3RlZFxuICAgICAgICAgIEZST00gbWVzc2FnZV9yZWFjdGlvbnNcbiAgICAgICAgICBHUk9VUCBCWSBtZXNzYWdlX2lkLCBlbW9qaVxuICAgICAgICApIG1yIE9OIG0uaWQgPSBtci5tZXNzYWdlX2lkXG4gICAgICAgIExFRlQgSk9JTiBtZXNzYWdlcyBwbSBPTiBtLnBhcmVudF9tZXNzYWdlX2lkID0gcG0uaWRcbiAgICAgICAgTEVGVCBKT0lOIHVzZXJzIHB1IE9OIHBtLnNlbmRlcl9pZCA9IHB1LmlkXG4gICAgICAgIFdIRVJFIG0uY2hhdF90eXBlID0gJHtjaGF0VHlwZX0gQU5EIG0uY2hhdF9pZCA9ICR7Y2hhdElkfVxuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRNZXNzYWdlcyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2UoXG4gIHNlbmRlcklkOiBzdHJpbmcsXG4gIGNvbnRlbnQ6IHN0cmluZyxcbiAgY2hhdFR5cGU6IHN0cmluZyxcbiAgY2hhdElkPzogc3RyaW5nLFxuICBtZW50aW9uczogc3RyaW5nW10gPSBbXSxcbiAgaXNBaVJlc3BvbnNlID0gZmFsc2UsXG4gIHBhcmVudE1lc3NhZ2VJZD86IHN0cmluZyxcbiAgbWVzc2FnZVR5cGUgPSBcInRleHRcIixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIG1lc3NhZ2VzIChzZW5kZXJfaWQsIGNvbnRlbnQsIGNoYXRfdHlwZSwgY2hhdF9pZCwgbWVudGlvbnMsIGlzX2FpX3Jlc3BvbnNlLCBwYXJlbnRfbWVzc2FnZV9pZCwgbWVzc2FnZV90eXBlKVxuICAgICAgVkFMVUVTICgke3NlbmRlcklkfSwgJHtjb250ZW50fSwgJHtjaGF0VHlwZX0sICR7Y2hhdElkfSwgJHttZW50aW9uc30sICR7aXNBaVJlc3BvbnNlfSwgJHtwYXJlbnRNZXNzYWdlSWR9LCAke21lc3NhZ2VUeXBlfSlcbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gY3JlYXRlTWVzc2FnZSBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwQ2hhdChuYW1lOiBzdHJpbmcsIGNyZWF0b3JJZDogc3RyaW5nLCBtZW1iZXJJZHM6IHN0cmluZ1tdID0gW10pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBJTlNFUlQgSU5UTyBncm91cF9jaGF0cyAobmFtZSwgY3JlYXRvcl9pZClcbiAgICAgIFZBTFVFUyAoJHtuYW1lfSwgJHtjcmVhdG9ySWR9KVxuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG5cbiAgICBhd2FpdCBzcWxgXG4gICAgICBJTlNFUlQgSU5UTyBncm91cF9jaGF0X21lbWJlcnMgKGdyb3VwX2NoYXRfaWQsIHVzZXJfaWQpXG4gICAgICBWQUxVRVMgKCR7cmVzdWx0WzBdLmlkfSwgJHtjcmVhdG9ySWR9KVxuICAgIGBcblxuICAgIGZvciAoY29uc3QgbWVtYmVySWQgb2YgbWVtYmVySWRzKSB7XG4gICAgICBpZiAobWVtYmVySWQgIT09IGNyZWF0b3JJZCkge1xuICAgICAgICBhd2FpdCBzcWxgXG4gICAgICAgICAgSU5TRVJUIElOVE8gZ3JvdXBfY2hhdF9tZW1iZXJzIChncm91cF9jaGF0X2lkLCB1c2VyX2lkKVxuICAgICAgICAgIFZBTFVFUyAoJHtyZXN1bHRbMF0uaWR9LCAke21lbWJlcklkfSlcbiAgICAgICAgICBPTiBDT05GTElDVCAoZ3JvdXBfY2hhdF9pZCwgdXNlcl9pZCkgRE8gTk9USElOR1xuICAgICAgICBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBjcmVhdGVHcm91cENoYXQgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyR3JvdXBDaGF0cyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBnYy4qLCB1LnVzZXJuYW1lIGFzIGNyZWF0b3JfdXNlcm5hbWVcbiAgICAgIEZST00gZ3JvdXBfY2hhdHMgZ2NcbiAgICAgIEpPSU4gZ3JvdXBfY2hhdF9tZW1iZXJzIGdjbSBPTiBnYy5pZCA9IGdjbS5ncm91cF9jaGF0X2lkXG4gICAgICBKT0lOIHVzZXJzIHUgT04gZ2MuY3JlYXRvcl9pZCA9IHUuaWRcbiAgICAgIFdIRVJFIGdjbS51c2VyX2lkID0gJHt1c2VySWR9XG4gICAgICBPUkRFUiBCWSBnYy51cGRhdGVkX2F0IERFU0NcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRVc2VyR3JvdXBDaGF0cyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUdyb3VwQ2hhdChncm91cElkOiBzdHJpbmcsIGNyZWF0b3JJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2hhdCA9IGF3YWl0IHNxbGBTRUxFQ1QgY3JlYXRvcl9pZCBGUk9NIGdyb3VwX2NoYXRzIFdIRVJFIGlkID0gJHtncm91cElkfWBcbiAgICBpZiAoIWNoYXRbMF0gfHwgY2hhdFswXS5jcmVhdG9yX2lkICE9PSBjcmVhdG9ySWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZCB0byBkZWxldGUgdGhpcyBncm91cCBjaGF0LlwiKVxuICAgIH1cblxuICAgIGF3YWl0IHNxbGBCRUdJTmBcbiAgICBhd2FpdCBzcWxgREVMRVRFIEZST00gbWVzc2FnZXMgV0hFUkUgY2hhdF90eXBlID0gJ2dyb3VwJyBBTkQgY2hhdF9pZCA9ICR7Z3JvdXBJZH1gXG4gICAgYXdhaXQgc3FsYERFTEVURSBGUk9NIGdyb3VwX2NoYXRfbWVtYmVycyBXSEVSRSBncm91cF9jaGF0X2lkID0gJHtncm91cElkfWBcbiAgICBhd2FpdCBzcWxgREVMRVRFIEZST00gZ3JvdXBfY2hhdHMgV0hFUkUgaWQgPSAke2dyb3VwSWR9YFxuICAgIGF3YWl0IHNxbGBDT01NSVRgXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhd2FpdCBzcWxgUk9MTEJBQ0tgXG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZGVsZXRlR3JvdXBDaGF0IGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRnJpZW5kc2hpcChyZXF1ZXN0ZXJJZDogc3RyaW5nLCBhZGRyZXNzZWVJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgaWYgKHJlcXVlc3RlcklkID09PSBhZGRyZXNzZWVJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlbmQgZnJpZW5kIHJlcXVlc3QgdG8geW91cnNlbGYuXCIpXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgKiBGUk9NIGZyaWVuZHNoaXBzXG4gICAgICBXSEVSRSAocmVxdWVzdGVyX2lkID0gJHtyZXF1ZXN0ZXJJZH0gQU5EIGFkZHJlc3NlZV9pZCA9ICR7YWRkcmVzc2VlSWR9KVxuICAgICAgICAgT1IgKHJlcXVlc3Rlcl9pZCA9ICR7YWRkcmVzc2VlSWR9IEFORCBhZGRyZXNzZWVfaWQgPSAke3JlcXVlc3RlcklkfSlcbiAgICAgIExJTUlUIDFcbiAgICBgXG5cbiAgICBpZiAoZXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGV4aXN0aW5nWzBdLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJpZW5kIHJlcXVlc3QgYWxyZWFkeSBwZW5kaW5nLlwiKVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1swXS5zdGF0dXMgPT09IFwiYWNjZXB0ZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGZyaWVuZHMgd2l0aCB0aGlzIHVzZXIuXCIpXG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nWzBdLnN0YXR1cyA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlbmQgcmVxdWVzdCBkdWUgdG8gZXhpc3RpbmcgYmxvY2suXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gZnJpZW5kc2hpcHMgKHJlcXVlc3Rlcl9pZCwgYWRkcmVzc2VlX2lkLCBzdGF0dXMpXG4gICAgICBWQUxVRVMgKCR7cmVxdWVzdGVySWR9LCAke2FkZHJlc3NlZUlkfSwgJ3BlbmRpbmcnKVxuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBjcmVhdGVGcmllbmRzaGlwIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRnJpZW5kc2hpcFN0YXR1cyhmcmllbmRzaGlwSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBVUERBVEUgZnJpZW5kc2hpcHMgXG4gICAgICBTRVQgc3RhdHVzID0gJHtzdGF0dXN9LCB1cGRhdGVkX2F0ID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHtmcmllbmRzaGlwSWR9XG4gICAgICBSRVRVUk5JTkcgKlxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIHVwZGF0ZUZyaWVuZHNoaXBTdGF0dXMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGcmllbmRzaGlwcyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBmLiosIFxuICAgICAgICAgICAgIHUxLnVzZXJuYW1lIGFzIHJlcXVlc3Rlcl91c2VybmFtZSxcbiAgICAgICAgICAgICB1Mi51c2VybmFtZSBhcyBhZGRyZXNzZWVfdXNlcm5hbWUsXG4gICAgICAgICAgICAgdTEubmFtZV9jb2xvciBhcyByZXF1ZXN0ZXJfbmFtZV9jb2xvcixcbiAgICAgICAgICAgICB1Mi5uYW1lX2NvbG9yIGFzIGFkZHJlc3NlZV9uYW1lX2NvbG9yLFxuICAgICAgICAgICAgIHUxLmhhc19nb2xkX2FuaW1hdGlvbiBhcyByZXF1ZXN0ZXJfaGFzX2dvbGQsXG4gICAgICAgICAgICAgdTIuaGFzX2dvbGRfYW5pbWF0aW9uIGFzIGFkZHJlc3NlZV9oYXNfZ29sZFxuICAgICAgRlJPTSBmcmllbmRzaGlwcyBmXG4gICAgICBKT0lOIHVzZXJzIHUxIE9OIGYucmVxdWVzdGVyX2lkID0gdTEuaWRcbiAgICAgIEpPSU4gdXNlcnMgdTIgT04gZi5hZGRyZXNzZWVfaWQgPSB1Mi5pZFxuICAgICAgV0hFUkUgKGYucmVxdWVzdGVyX2lkID0gJHt1c2VySWR9IE9SIGYuYWRkcmVzc2VlX2lkID0gJHt1c2VySWR9KVxuICAgICAgT1JERVIgQlkgZi5jcmVhdGVkX2F0IERFU0NcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRGcmllbmRzaGlwcyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjY2VwdGVkRnJpZW5kcyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBESVNUSU5DVFxuICAgICAgICBDQVNFIFxuICAgICAgICAgIFdIRU4gZi5yZXF1ZXN0ZXJfaWQgPSAke3VzZXJJZH0gVEhFTiB1Mi5pZFxuICAgICAgICAgIEVMU0UgdTEuaWRcbiAgICAgICAgRU5EIGFzIGZyaWVuZF9pZCxcbiAgICAgICAgQ0FTRSBcbiAgICAgICAgICBXSEVOIGYucmVxdWVzdGVyX2lkID0gJHt1c2VySWR9IFRIRU4gdTIudXNlcm5hbWVcbiAgICAgICAgICBFTFNFIHUxLnVzZXJuYW1lXG4gICAgICAgIEVORCBhcyBmcmllbmRfdXNlcm5hbWUsXG4gICAgICAgIENBU0UgXG4gICAgICAgICAgV0hFTiBmLnJlcXVlc3Rlcl9pZCA9ICR7dXNlcklkfSBUSEVOIHUyLm5hbWVfY29sb3JcbiAgICAgICAgICBFTFNFIHUxLm5hbWVfY29sb3JcbiAgICAgICAgRU5EIGFzIGZyaWVuZF9uYW1lX2NvbG9yLFxuICAgICAgICBDQVNFIFxuICAgICAgICAgIFdIRU4gZi5yZXF1ZXN0ZXJfaWQgPSAke3VzZXJJZH0gVEhFTiB1Mi5oYXNfZ29sZF9hbmltYXRpb25cbiAgICAgICAgICBFTFNFIHUxLmhhc19nb2xkX2FuaW1hdGlvblxuICAgICAgICBFTkQgYXMgZnJpZW5kX2hhc19nb2xkXG4gICAgICBGUk9NIGZyaWVuZHNoaXBzIGZcbiAgICAgIEpPSU4gdXNlcnMgdTEgT04gZi5yZXF1ZXN0ZXJfaWQgPSB1MS5pZFxuICAgICAgSk9JTiB1c2VycyB1MiBPTiBmLmFkZHJlc3NlZV9pZCA9IHUyLmlkXG4gICAgICBXSEVSRSAoZi5yZXF1ZXN0ZXJfaWQgPSAke3VzZXJJZH0gT1IgZi5hZGRyZXNzZWVfaWQgPSAke3VzZXJJZH0pXG4gICAgICBBTkQgZi5zdGF0dXMgPSAnYWNjZXB0ZWQnXG4gICAgICBPUkRFUiBCWSBmcmllbmRfdXNlcm5hbWVcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRBY2NlcHRlZEZyaWVuZHMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyRE1zKHVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgU0VMRUNUIERJU1RJTkNUXG4gICAgICAgIENBU0VcbiAgICAgICAgICBXSEVOIG0uc2VuZGVyX2lkID0gJHt1c2VySWR9IFRIRU4gbS5jaGF0X2lkXG4gICAgICAgICAgRUxTRSBtLnNlbmRlcl9pZFxuICAgICAgICBFTkQgYXMgZnJpZW5kX2lkLFxuICAgICAgICB1LnVzZXJuYW1lIGFzIGZyaWVuZF91c2VybmFtZSxcbiAgICAgICAgdS5uYW1lX2NvbG9yIGFzIGZyaWVuZF9uYW1lX2NvbG9yLFxuICAgICAgICB1Lmhhc19nb2xkX2FuaW1hdGlvbiBhcyBmcmllbmRfaGFzX2dvbGQsXG4gICAgICAgIE1BWChtLmNyZWF0ZWRfYXQpIGFzIGxhc3RfbWVzc2FnZV9hdFxuICAgICAgRlJPTSBtZXNzYWdlcyBtXG4gICAgICBKT0lOIHVzZXJzIHUgT04gXG4gICAgICAgIENBU0VcbiAgICAgICAgICBXSEVOIG0uc2VuZGVyX2lkID0gJHt1c2VySWR9IFRIRU4gbS5jaGF0X2lkXG4gICAgICAgICAgRUxTRSBtLnNlbmRlcl9pZFxuICAgICAgICBFTkQgPSB1LmlkXG4gICAgICBXSEVSRSBtLmNoYXRfdHlwZSA9ICdkbScgXG4gICAgICBBTkQgKG0uc2VuZGVyX2lkID0gJHt1c2VySWR9IE9SIG0uY2hhdF9pZCA9ICR7dXNlcklkfSlcbiAgICAgIEFORCB1LmlkICE9ICR7dXNlcklkfVxuICAgICAgQU5EIHUuaWQgIT0gJHtBSV9VU0VSX0lEfVxuICAgICAgR1JPVVAgQlkgZnJpZW5kX2lkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuaGFzX2dvbGRfYW5pbWF0aW9uXG4gICAgICBPUkRFUiBCWSBsYXN0X21lc3NhZ2VfYXQgREVTQ1xuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFVzZXJETXMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb24oXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIGNoYXRUeXBlPzogc3RyaW5nLFxuICBjaGF0SWQ/OiBzdHJpbmcsXG4gIHNlbmRlclVzZXJuYW1lPzogc3RyaW5nLFxuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gbm90aWZpY2F0aW9ucyAodXNlcl9pZCwgdGl0bGUsIG1lc3NhZ2UsIGNoYXRfdHlwZSwgY2hhdF9pZCwgc2VuZGVyX3VzZXJuYW1lKVxuICAgICAgVkFMVUVTICgke3VzZXJJZH0sICR7dGl0bGV9LCAke21lc3NhZ2V9LCAke2NoYXRUeXBlfSwgJHtjaGF0SWR9LCAke3NlbmRlclVzZXJuYW1lfSlcbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gY3JlYXRlTm90aWZpY2F0aW9uIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCAqIEZST00gbm90aWZpY2F0aW9uc1xuICAgICAgV0hFUkUgdXNlcl9pZCA9ICR7dXNlcklkfSBBTkQgaXNfcmVhZCA9IEZBTFNFXG4gICAgICBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRVbnJlYWROb3RpZmljYXRpb25zIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFya05vdGlmaWNhdGlvbkFzUmVhZChub3RpZmljYXRpb25JZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFVQREFURSBub3RpZmljYXRpb25zXG4gICAgICBTRVQgaXNfcmVhZCA9IFRSVUUsIGNyZWF0ZWRfYXQgPSBOT1coKVxuICAgICAgV0hFUkUgaWQgPSAke25vdGlmaWNhdGlvbklkfSBBTkQgdXNlcl9pZCA9ICR7dXNlcklkfVxuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBtYXJrTm90aWZpY2F0aW9uQXNSZWFkIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTWVzc2FnZVJlYWN0aW9uKG1lc3NhZ2VJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgZW1vamk6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIG1lc3NhZ2VfcmVhY3Rpb25zIChtZXNzYWdlX2lkLCB1c2VyX2lkLCBlbW9qaSlcbiAgICAgIFZBTFVFUyAoJHttZXNzYWdlSWR9LCAke3VzZXJJZH0sICR7ZW1vaml9KVxuICAgICAgT04gQ09ORkxJQ1QgKG1lc3NhZ2VfaWQsIHVzZXJfaWQsIGVtb2ppKSBETyBOT1RISU5HXG4gICAgICBSRVRVUk5JTkcgKlxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGFkZE1lc3NhZ2VSZWFjdGlvbiBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VSZWFjdGlvbihtZXNzYWdlSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIGVtb2ppOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzcWxgXG4gICAgICBERUxFVEUgRlJPTSBtZXNzYWdlX3JlYWN0aW9uc1xuICAgICAgV0hFUkUgbWVzc2FnZV9pZCA9ICR7bWVzc2FnZUlkfVxuICAgICAgICBBTkQgdXNlcl9pZCAgID0gJHt1c2VySWR9XG4gICAgICAgIEFORCBlbW9qaSAgICAgPSAke2Vtb2ppfVxuICAgIGBcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSByZW1vdmVNZXNzYWdlUmVhY3Rpb24gZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVVc2VyU2V0dGluZ3ModXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkge1xuICB0cnkge1xuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbXCJuYW1lX2NvbG9yXCIsIFwibm90aWZpY2F0aW9uc19lbmFibGVkXCIsIFwidGhlbWVcIiwgXCJodWVcIiwgXCJ1aV9tb2RlXCJdXG4gICAgY29uc3QgdmFsaWRVcGRhdGVzOiBhbnkgPSB7fVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXBkYXRlcykpIHtcbiAgICAgIGlmIChhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdmFsaWRVcGRhdGVzW2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyh2YWxpZFVwZGF0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgZmllbGRzIHRvIHVwZGF0ZVwiKVxuICAgIH1cblxuICAgIGNvbnN0IHNldENsYXVzZSA9IE9iamVjdC5rZXlzKHZhbGlkVXBkYXRlcylcbiAgICAgIC5tYXAoKGtleSwgaW5kZXgpID0+IGAke2tleX0gPSAkJHtpbmRleCArIDJ9YClcbiAgICAgIC5qb2luKFwiLCBcIilcblxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gYFxuICAgICAgVVBEQVRFIHVzZXJzIFxuICAgICAgU0VUICR7c2V0Q2xhdXNlfSwgdXBkYXRlZF9hdCA9IE5PVygpXG4gICAgICBXSEVSRSBpZCA9ICQxXG4gICAgICBSRVRVUk5JTkcgaWQsIHVzZXJuYW1lLCBlbWFpbCwgc2lnbnVwX2NvZGUsIG5hbWVfY29sb3IsIGN1c3RvbV90aXRsZSwgaGFzX2dvbGRfYW5pbWF0aW9uLCBub3RpZmljYXRpb25zX2VuYWJsZWQsIHRoZW1lLCBodWUsIHByb2ZpbGVfcGljdHVyZSwgYmlvLCB1aV9tb2RlXG4gICAgYFxuXG4gICAgY29uc3QgcGFyYW1zID0gW3VzZXJJZCwgLi4uT2JqZWN0LnZhbHVlcyh2YWxpZFVwZGF0ZXMpXVxuICAgIGNvbnN0IHJlc3VsdDogYW55W10gPSBhd2FpdCAoc3FsIGFzIGFueSkudW5zYWZlKHF1ZXJ5U3RyaW5nLCBwYXJhbXMgYXMgYW55KVxuXG4gICAgaWYgKCFyZXN1bHQgfHwgKHJlc3VsdCBhcyBhbnkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmQgb3Igbm8gc2V0dGluZ3MgdXBkYXRlZC5cIilcbiAgICB9XG5cbiAgICByZXR1cm4gKHJlc3VsdCBhcyBhbnkpWzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIHVwZGF0ZVVzZXJTZXR0aW5ncyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuLy8gRnJlZXplIGZlYXR1cmVcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRVc2VyRnJvemVuKHRhcmdldFVzZXJJZDogc3RyaW5nLCBmcm96ZW5CeVVzZXJJZDogc3RyaW5nLCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgVVBEQVRFIHVzZXJzXG4gICAgICBTRVQgaXNfZnJvemVuID0gVFJVRSwgZnJvemVuX2J5ID0gJHtmcm96ZW5CeVVzZXJJZH0sIGZyZWV6ZV9tZXNzYWdlID0gJHttZXNzYWdlIHx8IG51bGx9LCB1cGRhdGVkX2F0ID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHt0YXJnZXRVc2VySWR9XG4gICAgICBSRVRVUk5JTkcgaWQsIGlzX2Zyb3plbiwgZnJvemVuX2J5LCBmcmVlemVfbWVzc2FnZVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIHNldFVzZXJGcm96ZW4gZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhclVzZXJGcm96ZW4odGFyZ2V0VXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBVUERBVEUgdXNlcnNcbiAgICAgIFNFVCBpc19mcm96ZW4gPSBGQUxTRSwgZnJvemVuX2J5ID0gTlVMTCwgZnJlZXplX21lc3NhZ2UgPSBOVUxMLCB1cGRhdGVkX2F0ID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHt0YXJnZXRVc2VySWR9XG4gICAgICBSRVRVUk5JTkcgaWQsIGlzX2Zyb3plbiwgZnJvemVuX2J5LCBmcmVlemVfbWVzc2FnZVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGNsZWFyVXNlckZyb3plbiBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJGcmVlemVTdGF0dXModXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgaXNfZnJvemVuLCBmcm96ZW5fYnksIGZyZWV6ZV9tZXNzYWdlIEZST00gdXNlcnMgV0hFUkUgaWQgPSAke3VzZXJJZH1cbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRVc2VyRnJlZXplU3RhdHVzIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm5lb24iLCJBSV9VU0VSX0lEIiwiZGF0YWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiREFUQUJBU0VfVVJMIiwidXNlU1FMaXRlIiwiaW5jbHVkZXMiLCJzcWwiLCJjb25zb2xlIiwibG9nIiwibWVtb3J5RGIiLCJ1c2VycyIsIm1lc3NhZ2VzIiwiZnJpZW5kc2hpcHMiLCJncm91cF9jaGF0cyIsImdyb3VwX2NoYXRfbWVtYmVycyIsIm5vdGlmaWNhdGlvbnMiLCJtZXNzYWdlX3JlYWN0aW9ucyIsInBvbGxzIiwicG9sbF9yZXNwb25zZXMiLCJwb2xsX3NoYXJlcyIsImNhbGVuZGFyX2V2ZW50cyIsImNhbGVuZGFyX3BhcnRpY2lwYW50cyIsImNoYW5uZWxzIiwiaWQiLCJuYW1lIiwiY3JlYXRvcl9pZCIsImlzX3N5c3RlbSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwibW9ja0RiIiwicXVlcnkiLCJzdHJpbmdzIiwidmFsdWVzIiwiam9pbiIsInRvTG93ZXJDYXNlIiwidXNlcm5hbWUiLCJ1c2VyIiwiZmluZCIsInUiLCJmaWx0ZXIiLCJuZXdVc2VyIiwibm93IiwicGFzc3dvcmRfaGFzaCIsInNpZ251cF9jb2RlIiwibmFtZV9jb2xvciIsImN1c3RvbV90aXRsZSIsImhhc19nb2xkX2FuaW1hdGlvbiIsIm5vdGlmaWNhdGlvbnNfZW5hYmxlZCIsInRoZW1lIiwiaHVlIiwicHJvZmlsZV9waWN0dXJlIiwiYmlvIiwidWlfbW9kZSIsImxhc3RfYWN0aXZlIiwiaXNfZnJvemVuIiwiZnJvemVuX2J5IiwiZnJlZXplX21lc3NhZ2UiLCJmcmVlemVfcG9wdXBfbWVzc2FnZSIsImZyZWV6ZV91cGRhdGVkX2F0IiwidXBkYXRlZF9hdCIsInB1c2giLCJtYXAiLCJtc2ciLCJyZWFjdGlvbnMiLCJwYXJlbnRfbWVzc2FnZV9jb250ZW50IiwicGFyZW50X21lc3NhZ2VfdXNlcm5hbWUiLCJuZXdNZXNzYWdlIiwic2VuZGVyX2lkIiwiY29udGVudCIsImNoYXRfdHlwZSIsImNoYXRfaWQiLCJtZW50aW9ucyIsImlzX2FpX3Jlc3BvbnNlIiwicGFyZW50X21lc3NhZ2VfaWQiLCJtZXNzYWdlX3R5cGUiLCJ1bnNhZmUiLCJwYXJhbXMiLCJjaGFuZ2VzIiwiZXJyb3IiLCJkYiIsImNyZWF0ZVVzZXIiLCJwYXNzd29yZEhhc2giLCJzaWdudXBDb2RlIiwibmFtZUNvbG9yIiwiY3VzdG9tVGl0bGUiLCJoYXNHb2xkQW5pbWF0aW9uIiwicmVzdWx0IiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0VXNlckJ5VXNlcm5hbWUiLCJyb3dzIiwiZ2V0VXNlckJ5SWQiLCJ1cGRhdGVVc2VyQWN0aXZpdHkiLCJ1c2VySWQiLCJnZXRPbmxpbmVVc2VycyIsImN1cnJlbnRVc2VySWQiLCJzZWFyY2hVc2VycyIsInNlYXJjaFF1ZXJ5IiwiZ2V0TWVzc2FnZXMiLCJjaGF0VHlwZSIsImNoYXRJZCIsImxpbWl0IiwicmV2ZXJzZSIsImNyZWF0ZU1lc3NhZ2UiLCJzZW5kZXJJZCIsImlzQWlSZXNwb25zZSIsInBhcmVudE1lc3NhZ2VJZCIsIm1lc3NhZ2VUeXBlIiwiY3JlYXRlR3JvdXBDaGF0IiwiY3JlYXRvcklkIiwibWVtYmVySWRzIiwibWVtYmVySWQiLCJnZXRVc2VyR3JvdXBDaGF0cyIsImRlbGV0ZUdyb3VwQ2hhdCIsImdyb3VwSWQiLCJjaGF0IiwiY3JlYXRlRnJpZW5kc2hpcCIsInJlcXVlc3RlcklkIiwiYWRkcmVzc2VlSWQiLCJleGlzdGluZyIsImxlbmd0aCIsInN0YXR1cyIsInVwZGF0ZUZyaWVuZHNoaXBTdGF0dXMiLCJmcmllbmRzaGlwSWQiLCJnZXRGcmllbmRzaGlwcyIsImdldEFjY2VwdGVkRnJpZW5kcyIsImdldFVzZXJETXMiLCJjcmVhdGVOb3RpZmljYXRpb24iLCJ0aXRsZSIsInNlbmRlclVzZXJuYW1lIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyIsIm1hcmtOb3RpZmljYXRpb25Bc1JlYWQiLCJub3RpZmljYXRpb25JZCIsImFkZE1lc3NhZ2VSZWFjdGlvbiIsIm1lc3NhZ2VJZCIsImVtb2ppIiwicmVtb3ZlTWVzc2FnZVJlYWN0aW9uIiwidXBkYXRlVXNlclNldHRpbmdzIiwidXBkYXRlcyIsImFsbG93ZWRGaWVsZHMiLCJ2YWxpZFVwZGF0ZXMiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJrZXlzIiwic2V0Q2xhdXNlIiwiaW5kZXgiLCJxdWVyeVN0cmluZyIsInNldFVzZXJGcm96ZW4iLCJ0YXJnZXRVc2VySWQiLCJmcm96ZW5CeVVzZXJJZCIsImNsZWFyVXNlckZyb3plbiIsImdldFVzZXJGcmVlemVTdGF0dXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./lib/db.ts\n");

/***/ })

});