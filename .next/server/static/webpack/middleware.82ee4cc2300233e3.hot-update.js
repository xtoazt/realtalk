"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("middleware",{

/***/ "(middleware)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMessageReaction: () => (/* binding */ addMessageReaction),\n/* harmony export */   approveJoinRequest: () => (/* binding */ approveJoinRequest),\n/* harmony export */   clearUserFrozen: () => (/* binding */ clearUserFrozen),\n/* harmony export */   createFriendship: () => (/* binding */ createFriendship),\n/* harmony export */   createGroupChat: () => (/* binding */ createGroupChat),\n/* harmony export */   createJoinRequest: () => (/* binding */ createJoinRequest),\n/* harmony export */   createMessage: () => (/* binding */ createMessage),\n/* harmony export */   createNotification: () => (/* binding */ createNotification),\n/* harmony export */   createUser: () => (/* binding */ createUser),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   deleteGroupChat: () => (/* binding */ deleteGroupChat),\n/* harmony export */   getAcceptedFriends: () => (/* binding */ getAcceptedFriends),\n/* harmony export */   getFriendships: () => (/* binding */ getFriendships),\n/* harmony export */   getGroupChatByShortCode: () => (/* binding */ getGroupChatByShortCode),\n/* harmony export */   getMessages: () => (/* binding */ getMessages),\n/* harmony export */   getOnlineUsers: () => (/* binding */ getOnlineUsers),\n/* harmony export */   getPendingJoinRequests: () => (/* binding */ getPendingJoinRequests),\n/* harmony export */   getUnreadNotifications: () => (/* binding */ getUnreadNotifications),\n/* harmony export */   getUserById: () => (/* binding */ getUserById),\n/* harmony export */   getUserByUsername: () => (/* binding */ getUserByUsername),\n/* harmony export */   getUserDMs: () => (/* binding */ getUserDMs),\n/* harmony export */   getUserFreezeStatus: () => (/* binding */ getUserFreezeStatus),\n/* harmony export */   getUserGroupChats: () => (/* binding */ getUserGroupChats),\n/* harmony export */   markNotificationAsRead: () => (/* binding */ markNotificationAsRead),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   rejectJoinRequest: () => (/* binding */ rejectJoinRequest),\n/* harmony export */   removeMessageReaction: () => (/* binding */ removeMessageReaction),\n/* harmony export */   searchUsers: () => (/* binding */ searchUsers),\n/* harmony export */   setUserFrozen: () => (/* binding */ setUserFrozen),\n/* harmony export */   updateFriendshipStatus: () => (/* binding */ updateFriendshipStatus),\n/* harmony export */   updateUserActivity: () => (/* binding */ updateUserActivity),\n/* harmony export */   updateUserSettings: () => (/* binding */ updateUserSettings)\n/* harmony export */ });\n/* harmony import */ var server_only__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! server-only */ \"(middleware)/./node_modules/.pnpm/next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/server-only/empty.js\");\n/* harmony import */ var server_only__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(server_only__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neondatabase/serverless */ \"(middleware)/./node_modules/.pnpm/@neondatabase+serverless@1.0.1/node_modules/@neondatabase/serverless/index.mjs\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/constants */ \"(middleware)/./lib/constants.ts\");\n\n\n\nconst sql = (0,_neondatabase_serverless__WEBPACK_IMPORTED_MODULE_1__.neon)(process.env.DATABASE_URL);\nconst query = sql;\nconst db = sql;\n// Database helper functions\nasync function createUser(username, passwordHash, signupCode) {\n    try {\n        let nameColor = null;\n        const customTitle = null;\n        let hasGoldAnimation = false;\n        if (signupCode === \"asdf\") {\n            nameColor = \"#6366f1\";\n        } else if (signupCode === \"qwea\") {\n            hasGoldAnimation = true;\n        }\n        const result = await sql`\n      INSERT INTO users (username, password_hash, signup_code, name_color, has_gold_animation, email, last_active, theme, hue, ui_mode)\n      VALUES (${username}, ${passwordHash}, ${signupCode}, ${nameColor}, ${hasGoldAnimation}, NULL, NOW(), 'light', 'blue', 'full')\n      RETURNING id, username, email, signup_code, name_color, custom_title, has_gold_animation, notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createUser error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserByUsername(username) {\n    try {\n        const rows = await sql`\n      SELECT *\n      FROM users\n      WHERE username = ${username}\n      LIMIT 1\n    `;\n        return rows[0];\n    } catch (err) {\n        console.error(\"[db] getUserByUsername error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserById(id) {\n    try {\n        const result = await sql`\n      SELECT id, username, email, signup_code, name_color, custom_title, has_gold_animation, \n             notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n      FROM users WHERE id = ${id}\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] getUserById error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateUserActivity(userId) {\n    try {\n        await sql`\n      UPDATE users \n      SET last_active = NOW()\n      WHERE id = ${userId}\n    `;\n        return true;\n    } catch (err) {\n        console.error(\"[db] updateUserActivity error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getOnlineUsers(currentUserId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT u.id, u.username, u.name_color, u.has_gold_animation, u.last_active\n      FROM users u\n      JOIN friendships f ON (\n        (f.requester_id = ${currentUserId} AND f.addressee_id = u.id) OR\n        (f.addressee_id = ${currentUserId} AND f.requester_id = u.id)\n      )\n      WHERE u.last_active > NOW() - INTERVAL '10 minutes'\n      AND f.status = 'accepted'\n      AND u.id != ${currentUserId}\n      AND u.id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      ORDER BY u.username\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getOnlineUsers error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function searchUsers(searchQuery, currentUserId) {\n    try {\n        const result = await sql`\n      SELECT id, username, name_color, custom_title, has_gold_animation\n      FROM users \n      WHERE username ILIKE ${`%${searchQuery}%`} \n      AND id != ${currentUserId}\n      AND id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      LIMIT 10\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] searchUsers error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getMessages(chatType, chatId, userId, limit = 50) {\n    try {\n        if (chatType === \"global\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'global'\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else if (chatType === \"dm\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'dm' \n          AND ((m.sender_id = ${userId} AND m.chat_id = ${chatId}) \n               OR (m.sender_id = ${chatId} AND m.chat_id = ${userId}))\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else if (chatType === \"channel\") {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = 'channel' AND m.chat_id = ${chatId}\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        } else {\n            const result = await sql`\n        SELECT m.*, u.username, u.name_color, u.custom_title, u.has_gold_animation,\n               COALESCE(\n                 json_agg(\n                   json_build_object(\n                     'emoji', mr.emoji,\n                     'count', mr.reaction_count,\n                     'reacted_by_me', CASE WHEN mr.user_reacted THEN true ELSE false END\n                   )\n                 ) FILTER (WHERE mr.emoji IS NOT NULL), \n                 '[]'::json\n               ) as reactions,\n               pm.content AS parent_message_content,\n               pu.username AS parent_message_username\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        LEFT JOIN (\n          SELECT \n            message_id,\n            emoji,\n            COUNT(*) as reaction_count,\n            BOOL_OR(user_id = ${userId || null}) as user_reacted\n          FROM message_reactions\n          GROUP BY message_id, emoji\n        ) mr ON m.id = mr.message_id\n        LEFT JOIN messages pm ON m.parent_message_id = pm.id\n        LEFT JOIN users pu ON pm.sender_id = pu.id\n        WHERE m.chat_type = ${chatType} AND m.chat_id = ${chatId}\n        GROUP BY m.id, u.username, u.name_color, u.custom_title, u.has_gold_animation, pm.content, pu.username\n        ORDER BY m.created_at DESC\n        LIMIT ${limit}\n      `;\n            return result.reverse();\n        }\n    } catch (err) {\n        console.error(\"[db] getMessages error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createMessage(senderId, content, chatType, chatId, mentions = [], isAiResponse = false, parentMessageId, messageType = \"text\") {\n    try {\n        const result = await sql`\n      INSERT INTO messages (sender_id, content, chat_type, chat_id, mentions, is_ai_response, parent_message_id, message_type)\n      VALUES (${senderId}, ${content}, ${chatType}, ${chatId}, ${mentions}, ${isAiResponse}, ${parentMessageId}, ${messageType})\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createMessage error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\n// Generate a random short code\nfunction generateShortCode() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let result = '';\n    for(let i = 0; i < 6; i++){\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n}\nasync function createGroupChat(name, creatorId, memberIds = []) {\n    try {\n        // Generate a unique short code\n        let shortCode;\n        let attempts = 0;\n        let existing;\n        do {\n            shortCode = generateShortCode();\n            existing = await sql`SELECT id FROM group_chats WHERE short_code = ${shortCode}`;\n            attempts++;\n            if (attempts > 10) {\n                throw new Error(\"Failed to generate unique short code\");\n            }\n        }while (existing.length > 0);\n        const result = await sql`\n      INSERT INTO group_chats (name, creator_id, short_code)\n      VALUES (${name}, ${creatorId}, ${shortCode})\n      RETURNING *\n    `;\n        await sql`\n      INSERT INTO group_chat_members (group_chat_id, user_id)\n      VALUES (${result[0].id}, ${creatorId})\n    `;\n        for (const memberId of memberIds){\n            if (memberId !== creatorId) {\n                await sql`\n          INSERT INTO group_chat_members (group_chat_id, user_id)\n          VALUES (${result[0].id}, ${memberId})\n          ON CONFLICT (group_chat_id, user_id) DO NOTHING\n        `;\n            }\n        }\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createGroupChat error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserGroupChats(userId) {\n    try {\n        const result = await sql`\n      SELECT gc.*, u.username as creator_username\n      FROM group_chats gc\n      JOIN group_chat_members gcm ON gc.id = gcm.group_chat_id\n      JOIN users u ON gc.creator_id = u.id\n      WHERE gcm.user_id = ${userId}\n      ORDER BY gc.updated_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUserGroupChats error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getGroupChatByShortCode(shortCode) {\n    try {\n        const result = await sql`\n      SELECT gc.*, u.username as creator_username\n      FROM group_chats gc\n      JOIN users u ON gc.creator_id = u.id\n      WHERE gc.short_code = ${shortCode}\n      LIMIT 1\n    `;\n        return result[0] || null;\n    } catch (err) {\n        console.error(\"[db] getGroupChatByShortCode error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createJoinRequest(groupChatId, requesterId) {\n    try {\n        // Check if user is already a member\n        const existingMember = await sql`\n      SELECT id FROM group_chat_members \n      WHERE group_chat_id = ${groupChatId} AND user_id = ${requesterId}\n    `;\n        if (existingMember.length > 0) {\n            throw new Error(\"Already a member of this group chat\");\n        }\n        // Check if there's already a pending request\n        const existingRequest = await sql`\n      SELECT id FROM group_join_requests \n      WHERE group_chat_id = ${groupChatId} AND requester_id = ${requesterId}\n    `;\n        if (existingRequest.length > 0) {\n            throw new Error(\"Join request already pending\");\n        }\n        const result = await sql`\n      INSERT INTO group_join_requests (group_chat_id, requester_id, status)\n      VALUES (${groupChatId}, ${requesterId}, 'pending')\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createJoinRequest error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getPendingJoinRequests(groupChatId) {\n    try {\n        const result = await sql`\n      SELECT gjr.*, u.username, u.name_color, u.custom_title, u.has_gold_animation\n      FROM group_join_requests gjr\n      JOIN users u ON gjr.requester_id = u.id\n      WHERE gjr.group_chat_id = ${groupChatId} AND gjr.status = 'pending'\n      ORDER BY gjr.created_at ASC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getPendingJoinRequests error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function approveJoinRequest(requestId, groupChatId, requesterId) {\n    try {\n        await sql`BEGIN`;\n        // Update the request status\n        await sql`\n      UPDATE group_join_requests \n      SET status = 'approved', updated_at = NOW()\n      WHERE id = ${requestId}\n    `;\n        // Add user to group chat members\n        await sql`\n      INSERT INTO group_chat_members (group_chat_id, user_id)\n      VALUES (${groupChatId}, ${requesterId})\n      ON CONFLICT (group_chat_id, user_id) DO NOTHING\n    `;\n        await sql`COMMIT`;\n        return true;\n    } catch (err) {\n        await sql`ROLLBACK`;\n        console.error(\"[db] approveJoinRequest error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function rejectJoinRequest(requestId) {\n    try {\n        const result = await sql`\n      UPDATE group_join_requests \n      SET status = 'rejected', updated_at = NOW()\n      WHERE id = ${requestId}\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] rejectJoinRequest error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function deleteGroupChat(groupId, creatorId) {\n    try {\n        const chat = await sql`SELECT creator_id FROM group_chats WHERE id = ${groupId}`;\n        if (!chat[0] || chat[0].creator_id !== creatorId) {\n            throw new Error(\"Unauthorized to delete this group chat.\");\n        }\n        await sql`BEGIN`;\n        await sql`DELETE FROM messages WHERE chat_type = 'group' AND chat_id = ${groupId}`;\n        await sql`DELETE FROM group_chat_members WHERE group_chat_id = ${groupId}`;\n        await sql`DELETE FROM group_chats WHERE id = ${groupId}`;\n        await sql`COMMIT`;\n        return true;\n    } catch (err) {\n        await sql`ROLLBACK`;\n        console.error(\"[db] deleteGroupChat error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createFriendship(requesterId, addresseeId) {\n    try {\n        if (requesterId === addresseeId) {\n            throw new Error(\"Cannot send friend request to yourself.\");\n        }\n        const existing = await sql`\n      SELECT * FROM friendships\n      WHERE (requester_id = ${requesterId} AND addressee_id = ${addresseeId})\n         OR (requester_id = ${addresseeId} AND addressee_id = ${requesterId})\n      LIMIT 1\n    `;\n        if (existing.length > 0) {\n            if (existing[0].status === \"pending\") {\n                throw new Error(\"Friend request already pending.\");\n            } else if (existing[0].status === \"accepted\") {\n                throw new Error(\"Already friends with this user.\");\n            } else if (existing[0].status === \"blocked\") {\n                throw new Error(\"Cannot send request due to existing block.\");\n            }\n        }\n        const result = await sql`\n      INSERT INTO friendships (requester_id, addressee_id, status)\n      VALUES (${requesterId}, ${addresseeId}, 'pending')\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createFriendship error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateFriendshipStatus(friendshipId, status) {\n    try {\n        const result = await sql`\n      UPDATE friendships \n      SET status = ${status}, updated_at = NOW()\n      WHERE id = ${friendshipId}\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] updateFriendshipStatus error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getFriendships(userId) {\n    try {\n        const result = await sql`\n      SELECT f.*, \n             u1.username as requester_username,\n             u2.username as addressee_username,\n             u1.name_color as requester_name_color,\n             u2.name_color as addressee_name_color,\n             u1.has_gold_animation as requester_has_gold,\n             u2.has_gold_animation as addressee_has_gold\n      FROM friendships f\n      JOIN users u1 ON f.requester_id = u1.id\n      JOIN users u2 ON f.addressee_id = u2.id\n      WHERE (f.requester_id = ${userId} OR f.addressee_id = ${userId})\n      ORDER BY f.created_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getFriendships error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getAcceptedFriends(userId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.id\n          ELSE u1.id\n        END as friend_id,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.username\n          ELSE u1.username\n        END as friend_username,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.name_color\n          ELSE u1.name_color\n        END as friend_name_color,\n        CASE \n          WHEN f.requester_id = ${userId} THEN u2.has_gold_animation\n          ELSE u1.has_gold_animation\n        END as friend_has_gold\n      FROM friendships f\n      JOIN users u1 ON f.requester_id = u1.id\n      JOIN users u2 ON f.addressee_id = u2.id\n      WHERE (f.requester_id = ${userId} OR f.addressee_id = ${userId})\n      AND f.status = 'accepted'\n      ORDER BY friend_username\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getAcceptedFriends error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserDMs(userId) {\n    try {\n        const result = await sql`\n      SELECT DISTINCT\n        CASE\n          WHEN m.sender_id = ${userId} THEN m.chat_id\n          ELSE m.sender_id\n        END as friend_id,\n        u.username as friend_username,\n        u.name_color as friend_name_color,\n        u.has_gold_animation as friend_has_gold,\n        MAX(m.created_at) as last_message_at\n      FROM messages m\n      JOIN users u ON \n        CASE\n          WHEN m.sender_id = ${userId} THEN m.chat_id\n          ELSE m.sender_id\n        END = u.id\n      WHERE m.chat_type = 'dm' \n      AND (m.sender_id = ${userId} OR m.chat_id = ${userId})\n      AND u.id != ${userId}\n      AND u.id != ${_lib_constants__WEBPACK_IMPORTED_MODULE_2__.AI_USER_ID}\n      GROUP BY friend_id, u.username, u.name_color, u.has_gold_animation\n      ORDER BY last_message_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUserDMs error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function createNotification(userId, title, message, chatType, chatId, senderUsername) {\n    try {\n        const result = await sql`\n      INSERT INTO notifications (user_id, title, message, chat_type, chat_id, sender_username)\n      VALUES (${userId}, ${title}, ${message}, ${chatType}, ${chatId}, ${senderUsername})\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] createNotification error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUnreadNotifications(userId) {\n    try {\n        const result = await sql`\n      SELECT * FROM notifications\n      WHERE user_id = ${userId} AND is_read = FALSE\n      ORDER BY created_at DESC\n    `;\n        return result;\n    } catch (err) {\n        console.error(\"[db] getUnreadNotifications error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function markNotificationAsRead(notificationId, userId) {\n    try {\n        const result = await sql`\n      UPDATE notifications\n      SET is_read = TRUE, created_at = NOW()\n      WHERE id = ${notificationId} AND user_id = ${userId}\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] markNotificationAsRead error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function addMessageReaction(messageId, userId, emoji) {\n    try {\n        const result = await sql`\n      INSERT INTO message_reactions (message_id, user_id, emoji)\n      VALUES (${messageId}, ${userId}, ${emoji})\n      ON CONFLICT (message_id, user_id, emoji) DO NOTHING\n      RETURNING *\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] addMessageReaction error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function removeMessageReaction(messageId, userId, emoji) {\n    try {\n        await sql`\n      DELETE FROM message_reactions\n      WHERE message_id = ${messageId}\n        AND user_id   = ${userId}\n        AND emoji     = ${emoji}\n    `;\n        return true;\n    } catch (err) {\n        console.error(\"[db] removeMessageReaction error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function updateUserSettings(userId, updates) {\n    try {\n        const allowedFields = [\n            \"name_color\",\n            \"notifications_enabled\",\n            \"theme\",\n            \"hue\",\n            \"ui_mode\"\n        ];\n        const validUpdates = {};\n        for (const [key, value] of Object.entries(updates)){\n            if (allowedFields.includes(key)) {\n                validUpdates[key] = value;\n            }\n        }\n        if (Object.keys(validUpdates).length === 0) {\n            throw new Error(\"No valid fields to update\");\n        }\n        const setClause = Object.keys(validUpdates).map((key, index)=>`${key} = $${index + 2}`).join(\", \");\n        const queryString = `\n      UPDATE users \n      SET ${setClause}, updated_at = NOW()\n      WHERE id = $1\n      RETURNING id, username, email, signup_code, name_color, custom_title, has_gold_animation, notifications_enabled, theme, hue, profile_picture, bio, ui_mode\n    `;\n        const params = [\n            userId,\n            ...Object.values(validUpdates)\n        ];\n        const result = await sql.unsafe(queryString, params);\n        if (!result || result.length === 0) {\n            throw new Error(\"User not found or no settings updated.\");\n        }\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] updateUserSettings error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\n// Freeze feature\nasync function setUserFrozen(targetUserId, frozenByUserId, message) {\n    try {\n        const result = await sql`\n      UPDATE users\n      SET is_frozen = TRUE, frozen_by = ${frozenByUserId}, freeze_message = ${message || null}, updated_at = NOW()\n      WHERE id = ${targetUserId}\n      RETURNING id, is_frozen, frozen_by, freeze_message\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] setUserFrozen error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function clearUserFrozen(targetUserId) {\n    try {\n        const result = await sql`\n      UPDATE users\n      SET is_frozen = FALSE, frozen_by = NULL, freeze_message = NULL, updated_at = NOW()\n      WHERE id = ${targetUserId}\n      RETURNING id, is_frozen, frozen_by, freeze_message\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] clearUserFrozen error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\nasync function getUserFreezeStatus(userId) {\n    try {\n        const result = await sql`\n      SELECT is_frozen, frozen_by, freeze_message FROM users WHERE id = ${userId}\n    `;\n        return result[0];\n    } catch (err) {\n        console.error(\"[db] getUserFreezeStatus error:\", err);\n        throw new Error(\"Database error: \" + err.message);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDaEcsSUFBSTtRQUNGLE1BQU1MLFNBQVMsTUFBTWIsR0FBRyxDQUFDOzt3Q0FFVyxFQUFFOEcsZUFBZSxtQkFBbUIsRUFBRTVGLFdBQVcsS0FBSztpQkFDN0UsRUFBRTJGLGFBQWE7O0lBRTVCLENBQUM7UUFDRCxPQUFPaEcsTUFBTSxDQUFDLEVBQUU7SUFDbEIsRUFBRSxPQUFPQyxLQUFLO1FBQ1pDLFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJGO1FBQzNDLE1BQU0sSUFBSUcsTUFBTSxxQkFBcUIsSUFBZUMsT0FBTztJQUM3RDtBQUNGO0FBRU8sZUFBZTZGLGdCQUFnQkYsWUFBb0I7SUFDeEQsSUFBSTtRQUNGLE1BQU1oRyxTQUFTLE1BQU1iLEdBQUcsQ0FBQzs7O2lCQUdaLEVBQUU2RyxhQUFhOztJQUU1QixDQUFDO1FBQ0QsT0FBT2hHLE1BQU0sQ0FBQyxFQUFFO0lBQ2xCLEVBQUUsT0FBT0MsS0FBSztRQUNaQyxRQUFRQyxLQUFLLENBQUMsK0JBQStCRjtRQUM3QyxNQUFNLElBQUlHLE1BQU0scUJBQXFCLElBQWVDLE9BQU87SUFDN0Q7QUFDRjtBQUVPLGVBQWU4RixvQkFBb0J4RixNQUFjO0lBQ3RELElBQUk7UUFDRixNQUFNWCxTQUFTLE1BQU1iLEdBQUcsQ0FBQzt3RUFDMkMsRUFBRXdCLE9BQU87SUFDN0UsQ0FBQztRQUNELE9BQU9YLE1BQU0sQ0FBQyxFQUFFO0lBQ2xCLEVBQUUsT0FBT0MsS0FBSztRQUNaQyxRQUFRQyxLQUFLLENBQUMsbUNBQW1DRjtRQUNqRCxNQUFNLElBQUlHLE1BQU0scUJBQXFCLElBQWVDLE9BQU87SUFDN0Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3JvaGFuL2NvZGUvcmVhbHRhbGsvbGliL2RiLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcInNlcnZlci1vbmx5XCJcbmltcG9ydCB7IG5lb24gfSBmcm9tIFwiQG5lb25kYXRhYmFzZS9zZXJ2ZXJsZXNzXCJcbmltcG9ydCB7IEFJX1VTRVJfSUQgfSBmcm9tIFwiQC9saWIvY29uc3RhbnRzXCJcblxuY29uc3Qgc3FsID0gbmVvbihwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwhKVxuXG5leHBvcnQgY29uc3QgcXVlcnkgPSBzcWxcbmV4cG9ydCBjb25zdCBkYiA9IHNxbFxuXG4vLyBEYXRhYmFzZSBoZWxwZXIgZnVuY3Rpb25zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZEhhc2g6IHN0cmluZywgc2lnbnVwQ29kZT86IHN0cmluZykge1xuICB0cnkge1xuICAgIGxldCBuYW1lQ29sb3IgPSBudWxsXG4gICAgY29uc3QgY3VzdG9tVGl0bGUgPSBudWxsXG4gICAgbGV0IGhhc0dvbGRBbmltYXRpb24gPSBmYWxzZVxuXG4gICAgaWYgKHNpZ251cENvZGUgPT09IFwiYXNkZlwiKSB7XG4gICAgICBuYW1lQ29sb3IgPSBcIiM2MzY2ZjFcIlxuICAgIH0gZWxzZSBpZiAoc2lnbnVwQ29kZSA9PT0gXCJxd2VhXCIpIHtcbiAgICAgIGhhc0dvbGRBbmltYXRpb24gPSB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gdXNlcnMgKHVzZXJuYW1lLCBwYXNzd29yZF9oYXNoLCBzaWdudXBfY29kZSwgbmFtZV9jb2xvciwgaGFzX2dvbGRfYW5pbWF0aW9uLCBlbWFpbCwgbGFzdF9hY3RpdmUsIHRoZW1lLCBodWUsIHVpX21vZGUpXG4gICAgICBWQUxVRVMgKCR7dXNlcm5hbWV9LCAke3Bhc3N3b3JkSGFzaH0sICR7c2lnbnVwQ29kZX0sICR7bmFtZUNvbG9yfSwgJHtoYXNHb2xkQW5pbWF0aW9ufSwgTlVMTCwgTk9XKCksICdsaWdodCcsICdibHVlJywgJ2Z1bGwnKVxuICAgICAgUkVUVVJOSU5HIGlkLCB1c2VybmFtZSwgZW1haWwsIHNpZ251cF9jb2RlLCBuYW1lX2NvbG9yLCBjdXN0b21fdGl0bGUsIGhhc19nb2xkX2FuaW1hdGlvbiwgbm90aWZpY2F0aW9uc19lbmFibGVkLCB0aGVtZSwgaHVlLCBwcm9maWxlX3BpY3R1cmUsIGJpbywgdWlfbW9kZVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGNyZWF0ZVVzZXIgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyQnlVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgcm93cyA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIHVzZXJzXG4gICAgICBXSEVSRSB1c2VybmFtZSA9ICR7dXNlcm5hbWV9XG4gICAgICBMSU1JVCAxXG4gICAgYFxuICAgIHJldHVybiByb3dzWzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFVzZXJCeVVzZXJuYW1lIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckJ5SWQoaWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBpZCwgdXNlcm5hbWUsIGVtYWlsLCBzaWdudXBfY29kZSwgbmFtZV9jb2xvciwgY3VzdG9tX3RpdGxlLCBoYXNfZ29sZF9hbmltYXRpb24sIFxuICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNfZW5hYmxlZCwgdGhlbWUsIGh1ZSwgcHJvZmlsZV9waWN0dXJlLCBiaW8sIHVpX21vZGVcbiAgICAgIEZST00gdXNlcnMgV0hFUkUgaWQgPSAke2lkfVxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFVzZXJCeUlkIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlckFjdGl2aXR5KHVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgc3FsYFxuICAgICAgVVBEQVRFIHVzZXJzIFxuICAgICAgU0VUIGxhc3RfYWN0aXZlID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHt1c2VySWR9XG4gICAgYFxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIHVwZGF0ZVVzZXJBY3Rpdml0eSBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9ubGluZVVzZXJzKGN1cnJlbnRVc2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBESVNUSU5DVCB1LmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLCB1Lmxhc3RfYWN0aXZlXG4gICAgICBGUk9NIHVzZXJzIHVcbiAgICAgIEpPSU4gZnJpZW5kc2hpcHMgZiBPTiAoXG4gICAgICAgIChmLnJlcXVlc3Rlcl9pZCA9ICR7Y3VycmVudFVzZXJJZH0gQU5EIGYuYWRkcmVzc2VlX2lkID0gdS5pZCkgT1JcbiAgICAgICAgKGYuYWRkcmVzc2VlX2lkID0gJHtjdXJyZW50VXNlcklkfSBBTkQgZi5yZXF1ZXN0ZXJfaWQgPSB1LmlkKVxuICAgICAgKVxuICAgICAgV0hFUkUgdS5sYXN0X2FjdGl2ZSA+IE5PVygpIC0gSU5URVJWQUwgJzEwIG1pbnV0ZXMnXG4gICAgICBBTkQgZi5zdGF0dXMgPSAnYWNjZXB0ZWQnXG4gICAgICBBTkQgdS5pZCAhPSAke2N1cnJlbnRVc2VySWR9XG4gICAgICBBTkQgdS5pZCAhPSAke0FJX1VTRVJfSUR9XG4gICAgICBPUkRFUiBCWSB1LnVzZXJuYW1lXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0T25saW5lVXNlcnMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hVc2VycyhzZWFyY2hRdWVyeTogc3RyaW5nLCBjdXJyZW50VXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgaWQsIHVzZXJuYW1lLCBuYW1lX2NvbG9yLCBjdXN0b21fdGl0bGUsIGhhc19nb2xkX2FuaW1hdGlvblxuICAgICAgRlJPTSB1c2VycyBcbiAgICAgIFdIRVJFIHVzZXJuYW1lIElMSUtFICR7YCUke3NlYXJjaFF1ZXJ5fSVgfSBcbiAgICAgIEFORCBpZCAhPSAke2N1cnJlbnRVc2VySWR9XG4gICAgICBBTkQgaWQgIT0gJHtBSV9VU0VSX0lEfVxuICAgICAgTElNSVQgMTBcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBzZWFyY2hVc2VycyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lc3NhZ2VzKGNoYXRUeXBlOiBzdHJpbmcsIGNoYXRJZD86IHN0cmluZywgdXNlcklkPzogc3RyaW5nLCBsaW1pdCA9IDUwKSB7XG4gIHRyeSB7XG4gICAgaWYgKGNoYXRUeXBlID09PSBcImdsb2JhbFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICAgIFNFTEVDVCBtLiosIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgQ09BTEVTQ0UoXG4gICAgICAgICAgICAgICAgIGpzb25fYWdnKFxuICAgICAgICAgICAgICAgICAgIGpzb25fYnVpbGRfb2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgJ2Vtb2ppJywgbXIuZW1vamksXG4gICAgICAgICAgICAgICAgICAgICAnY291bnQnLCBtci5yZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICdyZWFjdGVkX2J5X21lJywgQ0FTRSBXSEVOIG1yLnVzZXJfcmVhY3RlZCBUSEVOIHRydWUgRUxTRSBmYWxzZSBFTkRcbiAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICkgRklMVEVSIChXSEVSRSBtci5lbW9qaSBJUyBOT1QgTlVMTCksIFxuICAgICAgICAgICAgICAgICAnW10nOjpqc29uXG4gICAgICAgICAgICAgICApIGFzIHJlYWN0aW9ucyxcbiAgICAgICAgICAgICAgIHBtLmNvbnRlbnQgQVMgcGFyZW50X21lc3NhZ2VfY29udGVudCxcbiAgICAgICAgICAgICAgIHB1LnVzZXJuYW1lIEFTIHBhcmVudF9tZXNzYWdlX3VzZXJuYW1lXG4gICAgICAgIEZST00gbWVzc2FnZXMgbVxuICAgICAgICBKT0lOIHVzZXJzIHUgT04gbS5zZW5kZXJfaWQgPSB1LmlkXG4gICAgICAgIExFRlQgSk9JTiAoXG4gICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgQ09VTlQoKikgYXMgcmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICBCT09MX09SKHVzZXJfaWQgPSAke3VzZXJJZCB8fCBudWxsfSkgYXMgdXNlcl9yZWFjdGVkXG4gICAgICAgICAgRlJPTSBtZXNzYWdlX3JlYWN0aW9uc1xuICAgICAgICAgIEdST1VQIEJZIG1lc3NhZ2VfaWQsIGVtb2ppXG4gICAgICAgICkgbXIgT04gbS5pZCA9IG1yLm1lc3NhZ2VfaWRcbiAgICAgICAgTEVGVCBKT0lOIG1lc3NhZ2VzIHBtIE9OIG0ucGFyZW50X21lc3NhZ2VfaWQgPSBwbS5pZFxuICAgICAgICBMRUZUIEpPSU4gdXNlcnMgcHUgT04gcG0uc2VuZGVyX2lkID0gcHUuaWRcbiAgICAgICAgV0hFUkUgbS5jaGF0X3R5cGUgPSAnZ2xvYmFsJ1xuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfSBlbHNlIGlmIChjaGF0VHlwZSA9PT0gXCJkbVwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICAgIFNFTEVDVCBtLiosIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgQ09BTEVTQ0UoXG4gICAgICAgICAgICAgICAgIGpzb25fYWdnKFxuICAgICAgICAgICAgICAgICAgIGpzb25fYnVpbGRfb2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgJ2Vtb2ppJywgbXIuZW1vamksXG4gICAgICAgICAgICAgICAgICAgICAnY291bnQnLCBtci5yZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICdyZWFjdGVkX2J5X21lJywgQ0FTRSBXSEVOIG1yLnVzZXJfcmVhY3RlZCBUSEVOIHRydWUgRUxTRSBmYWxzZSBFTkRcbiAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICkgRklMVEVSIChXSEVSRSBtci5lbW9qaSBJUyBOT1QgTlVMTCksIFxuICAgICAgICAgICAgICAgICAnW10nOjpqc29uXG4gICAgICAgICAgICAgICApIGFzIHJlYWN0aW9ucyxcbiAgICAgICAgICAgICAgIHBtLmNvbnRlbnQgQVMgcGFyZW50X21lc3NhZ2VfY29udGVudCxcbiAgICAgICAgICAgICAgIHB1LnVzZXJuYW1lIEFTIHBhcmVudF9tZXNzYWdlX3VzZXJuYW1lXG4gICAgICAgIEZST00gbWVzc2FnZXMgbVxuICAgICAgICBKT0lOIHVzZXJzIHUgT04gbS5zZW5kZXJfaWQgPSB1LmlkXG4gICAgICAgIExFRlQgSk9JTiAoXG4gICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgQ09VTlQoKikgYXMgcmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICBCT09MX09SKHVzZXJfaWQgPSAke3VzZXJJZCB8fCBudWxsfSkgYXMgdXNlcl9yZWFjdGVkXG4gICAgICAgICAgRlJPTSBtZXNzYWdlX3JlYWN0aW9uc1xuICAgICAgICAgIEdST1VQIEJZIG1lc3NhZ2VfaWQsIGVtb2ppXG4gICAgICAgICkgbXIgT04gbS5pZCA9IG1yLm1lc3NhZ2VfaWRcbiAgICAgICAgTEVGVCBKT0lOIG1lc3NhZ2VzIHBtIE9OIG0ucGFyZW50X21lc3NhZ2VfaWQgPSBwbS5pZFxuICAgICAgICBMRUZUIEpPSU4gdXNlcnMgcHUgT04gcG0uc2VuZGVyX2lkID0gcHUuaWRcbiAgICAgICAgV0hFUkUgbS5jaGF0X3R5cGUgPSAnZG0nIFxuICAgICAgICAgIEFORCAoKG0uc2VuZGVyX2lkID0gJHt1c2VySWR9IEFORCBtLmNoYXRfaWQgPSAke2NoYXRJZH0pIFxuICAgICAgICAgICAgICAgT1IgKG0uc2VuZGVyX2lkID0gJHtjaGF0SWR9IEFORCBtLmNoYXRfaWQgPSAke3VzZXJJZH0pKVxuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfSBlbHNlIGlmIChjaGF0VHlwZSA9PT0gXCJjaGFubmVsXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgICAgU0VMRUNUIG0uKiwgdS51c2VybmFtZSwgdS5uYW1lX2NvbG9yLCB1LmN1c3RvbV90aXRsZSwgdS5oYXNfZ29sZF9hbmltYXRpb24sXG4gICAgICAgICAgICAgICBDT0FMRVNDRShcbiAgICAgICAgICAgICAgICAganNvbl9hZ2coXG4gICAgICAgICAgICAgICAgICAganNvbl9idWlsZF9vYmplY3QoXG4gICAgICAgICAgICAgICAgICAgICAnZW1vamknLCBtci5lbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgICdjb3VudCcsIG1yLnJlYWN0aW9uX2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgJ3JlYWN0ZWRfYnlfbWUnLCBDQVNFIFdIRU4gbXIudXNlcl9yZWFjdGVkIFRIRU4gdHJ1ZSBFTFNFIGZhbHNlIEVORFxuICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgKSBGSUxURVIgKFdIRVJFIG1yLmVtb2ppIElTIE5PVCBOVUxMKSwgXG4gICAgICAgICAgICAgICAgICdbXSc6Ompzb25cbiAgICAgICAgICAgICAgICkgYXMgcmVhY3Rpb25zLFxuICAgICAgICAgICAgICAgcG0uY29udGVudCBBUyBwYXJlbnRfbWVzc2FnZV9jb250ZW50LFxuICAgICAgICAgICAgICAgcHUudXNlcm5hbWUgQVMgcGFyZW50X21lc3NhZ2VfdXNlcm5hbWVcbiAgICAgICAgRlJPTSBtZXNzYWdlcyBtXG4gICAgICAgIEpPSU4gdXNlcnMgdSBPTiBtLnNlbmRlcl9pZCA9IHUuaWRcbiAgICAgICAgTEVGVCBKT0lOIChcbiAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICBDT1VOVCgqKSBhcyByZWFjdGlvbl9jb3VudCxcbiAgICAgICAgICAgIEJPT0xfT1IodXNlcl9pZCA9ICR7dXNlcklkIHx8IG51bGx9KSBhcyB1c2VyX3JlYWN0ZWRcbiAgICAgICAgICBGUk9NIG1lc3NhZ2VfcmVhY3Rpb25zXG4gICAgICAgICAgR1JPVVAgQlkgbWVzc2FnZV9pZCwgZW1vamlcbiAgICAgICAgKSBtciBPTiBtLmlkID0gbXIubWVzc2FnZV9pZFxuICAgICAgICBMRUZUIEpPSU4gbWVzc2FnZXMgcG0gT04gbS5wYXJlbnRfbWVzc2FnZV9pZCA9IHBtLmlkXG4gICAgICAgIExFRlQgSk9JTiB1c2VycyBwdSBPTiBwbS5zZW5kZXJfaWQgPSBwdS5pZFxuICAgICAgICBXSEVSRSBtLmNoYXRfdHlwZSA9ICdjaGFubmVsJyBBTkQgbS5jaGF0X2lkID0gJHtjaGF0SWR9XG4gICAgICAgIEdST1VQIEJZIG0uaWQsIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uLCBwbS5jb250ZW50LCBwdS51c2VybmFtZVxuICAgICAgICBPUkRFUiBCWSBtLmNyZWF0ZWRfYXQgREVTQ1xuICAgICAgICBMSU1JVCAke2xpbWl0fVxuICAgICAgYFxuICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgICBTRUxFQ1QgbS4qLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbixcbiAgICAgICAgICAgICAgIENPQUxFU0NFKFxuICAgICAgICAgICAgICAgICBqc29uX2FnZyhcbiAgICAgICAgICAgICAgICAgICBqc29uX2J1aWxkX29iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICdlbW9qaScsIG1yLmVtb2ppLFxuICAgICAgICAgICAgICAgICAgICAgJ2NvdW50JywgbXIucmVhY3Rpb25fY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAncmVhY3RlZF9ieV9tZScsIENBU0UgV0hFTiBtci51c2VyX3JlYWN0ZWQgVEhFTiB0cnVlIEVMU0UgZmFsc2UgRU5EXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICApIEZJTFRFUiAoV0hFUkUgbXIuZW1vamkgSVMgTk9UIE5VTEwpLCBcbiAgICAgICAgICAgICAgICAgJ1tdJzo6anNvblxuICAgICAgICAgICAgICAgKSBhcyByZWFjdGlvbnMsXG4gICAgICAgICAgICAgICBwbS5jb250ZW50IEFTIHBhcmVudF9tZXNzYWdlX2NvbnRlbnQsXG4gICAgICAgICAgICAgICBwdS51c2VybmFtZSBBUyBwYXJlbnRfbWVzc2FnZV91c2VybmFtZVxuICAgICAgICBGUk9NIG1lc3NhZ2VzIG1cbiAgICAgICAgSk9JTiB1c2VycyB1IE9OIG0uc2VuZGVyX2lkID0gdS5pZFxuICAgICAgICBMRUZUIEpPSU4gKFxuICAgICAgICAgIFNFTEVDVCBcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgIENPVU5UKCopIGFzIHJlYWN0aW9uX2NvdW50LFxuICAgICAgICAgICAgQk9PTF9PUih1c2VyX2lkID0gJHt1c2VySWQgfHwgbnVsbH0pIGFzIHVzZXJfcmVhY3RlZFxuICAgICAgICAgIEZST00gbWVzc2FnZV9yZWFjdGlvbnNcbiAgICAgICAgICBHUk9VUCBCWSBtZXNzYWdlX2lkLCBlbW9qaVxuICAgICAgICApIG1yIE9OIG0uaWQgPSBtci5tZXNzYWdlX2lkXG4gICAgICAgIExFRlQgSk9JTiBtZXNzYWdlcyBwbSBPTiBtLnBhcmVudF9tZXNzYWdlX2lkID0gcG0uaWRcbiAgICAgICAgTEVGVCBKT0lOIHVzZXJzIHB1IE9OIHBtLnNlbmRlcl9pZCA9IHB1LmlkXG4gICAgICAgIFdIRVJFIG0uY2hhdF90eXBlID0gJHtjaGF0VHlwZX0gQU5EIG0uY2hhdF9pZCA9ICR7Y2hhdElkfVxuICAgICAgICBHUk9VUCBCWSBtLmlkLCB1LnVzZXJuYW1lLCB1Lm5hbWVfY29sb3IsIHUuY3VzdG9tX3RpdGxlLCB1Lmhhc19nb2xkX2FuaW1hdGlvbiwgcG0uY29udGVudCwgcHUudXNlcm5hbWVcbiAgICAgICAgT1JERVIgQlkgbS5jcmVhdGVkX2F0IERFU0NcbiAgICAgICAgTElNSVQgJHtsaW1pdH1cbiAgICAgIGBcbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRNZXNzYWdlcyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2UoXG4gIHNlbmRlcklkOiBzdHJpbmcsXG4gIGNvbnRlbnQ6IHN0cmluZyxcbiAgY2hhdFR5cGU6IHN0cmluZyxcbiAgY2hhdElkPzogc3RyaW5nLFxuICBtZW50aW9uczogc3RyaW5nW10gPSBbXSxcbiAgaXNBaVJlc3BvbnNlID0gZmFsc2UsXG4gIHBhcmVudE1lc3NhZ2VJZD86IHN0cmluZyxcbiAgbWVzc2FnZVR5cGUgPSBcInRleHRcIixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIG1lc3NhZ2VzIChzZW5kZXJfaWQsIGNvbnRlbnQsIGNoYXRfdHlwZSwgY2hhdF9pZCwgbWVudGlvbnMsIGlzX2FpX3Jlc3BvbnNlLCBwYXJlbnRfbWVzc2FnZV9pZCwgbWVzc2FnZV90eXBlKVxuICAgICAgVkFMVUVTICgke3NlbmRlcklkfSwgJHtjb250ZW50fSwgJHtjaGF0VHlwZX0sICR7Y2hhdElkfSwgJHttZW50aW9uc30sICR7aXNBaVJlc3BvbnNlfSwgJHtwYXJlbnRNZXNzYWdlSWR9LCAke21lc3NhZ2VUeXBlfSlcbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gY3JlYXRlTWVzc2FnZSBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuLy8gR2VuZXJhdGUgYSByYW5kb20gc2hvcnQgY29kZVxuZnVuY3Rpb24gZ2VuZXJhdGVTaG9ydENvZGUoKTogc3RyaW5nIHtcbiAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5J1xuICBsZXQgcmVzdWx0ID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR3JvdXBDaGF0KG5hbWU6IHN0cmluZywgY3JlYXRvcklkOiBzdHJpbmcsIG1lbWJlcklkczogc3RyaW5nW10gPSBbXSkge1xuICB0cnkge1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIHNob3J0IGNvZGVcbiAgICBsZXQgc2hvcnRDb2RlOiBzdHJpbmdcbiAgICBsZXQgYXR0ZW1wdHMgPSAwXG4gICAgbGV0IGV4aXN0aW5nOiBhbnlbXVxuICAgIGRvIHtcbiAgICAgIHNob3J0Q29kZSA9IGdlbmVyYXRlU2hvcnRDb2RlKClcbiAgICAgIGV4aXN0aW5nID0gYXdhaXQgc3FsYFNFTEVDVCBpZCBGUk9NIGdyb3VwX2NoYXRzIFdIRVJFIHNob3J0X2NvZGUgPSAke3Nob3J0Q29kZX1gXG4gICAgICBhdHRlbXB0cysrXG4gICAgICBpZiAoYXR0ZW1wdHMgPiAxMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIHNob3J0IGNvZGVcIilcbiAgICAgIH1cbiAgICB9IHdoaWxlIChleGlzdGluZy5sZW5ndGggPiAwKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gZ3JvdXBfY2hhdHMgKG5hbWUsIGNyZWF0b3JfaWQsIHNob3J0X2NvZGUpXG4gICAgICBWQUxVRVMgKCR7bmFtZX0sICR7Y3JlYXRvcklkfSwgJHtzaG9ydENvZGV9KVxuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG5cbiAgICBhd2FpdCBzcWxgXG4gICAgICBJTlNFUlQgSU5UTyBncm91cF9jaGF0X21lbWJlcnMgKGdyb3VwX2NoYXRfaWQsIHVzZXJfaWQpXG4gICAgICBWQUxVRVMgKCR7cmVzdWx0WzBdLmlkfSwgJHtjcmVhdG9ySWR9KVxuICAgIGBcblxuICAgIGZvciAoY29uc3QgbWVtYmVySWQgb2YgbWVtYmVySWRzKSB7XG4gICAgICBpZiAobWVtYmVySWQgIT09IGNyZWF0b3JJZCkge1xuICAgICAgICBhd2FpdCBzcWxgXG4gICAgICAgICAgSU5TRVJUIElOVE8gZ3JvdXBfY2hhdF9tZW1iZXJzIChncm91cF9jaGF0X2lkLCB1c2VyX2lkKVxuICAgICAgICAgIFZBTFVFUyAoJHtyZXN1bHRbMF0uaWR9LCAke21lbWJlcklkfSlcbiAgICAgICAgICBPTiBDT05GTElDVCAoZ3JvdXBfY2hhdF9pZCwgdXNlcl9pZCkgRE8gTk9USElOR1xuICAgICAgICBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBjcmVhdGVHcm91cENoYXQgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyR3JvdXBDaGF0cyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBnYy4qLCB1LnVzZXJuYW1lIGFzIGNyZWF0b3JfdXNlcm5hbWVcbiAgICAgIEZST00gZ3JvdXBfY2hhdHMgZ2NcbiAgICAgIEpPSU4gZ3JvdXBfY2hhdF9tZW1iZXJzIGdjbSBPTiBnYy5pZCA9IGdjbS5ncm91cF9jaGF0X2lkXG4gICAgICBKT0lOIHVzZXJzIHUgT04gZ2MuY3JlYXRvcl9pZCA9IHUuaWRcbiAgICAgIFdIRVJFIGdjbS51c2VyX2lkID0gJHt1c2VySWR9XG4gICAgICBPUkRFUiBCWSBnYy51cGRhdGVkX2F0IERFU0NcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRVc2VyR3JvdXBDaGF0cyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdyb3VwQ2hhdEJ5U2hvcnRDb2RlKHNob3J0Q29kZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgU0VMRUNUIGdjLiosIHUudXNlcm5hbWUgYXMgY3JlYXRvcl91c2VybmFtZVxuICAgICAgRlJPTSBncm91cF9jaGF0cyBnY1xuICAgICAgSk9JTiB1c2VycyB1IE9OIGdjLmNyZWF0b3JfaWQgPSB1LmlkXG4gICAgICBXSEVSRSBnYy5zaG9ydF9jb2RlID0gJHtzaG9ydENvZGV9XG4gICAgICBMSU1JVCAxXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF0gfHwgbnVsbFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRHcm91cENoYXRCeVNob3J0Q29kZSBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUpvaW5SZXF1ZXN0KGdyb3VwQ2hhdElkOiBzdHJpbmcsIHJlcXVlc3RlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFscmVhZHkgYSBtZW1iZXJcbiAgICBjb25zdCBleGlzdGluZ01lbWJlciA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBpZCBGUk9NIGdyb3VwX2NoYXRfbWVtYmVycyBcbiAgICAgIFdIRVJFIGdyb3VwX2NoYXRfaWQgPSAke2dyb3VwQ2hhdElkfSBBTkQgdXNlcl9pZCA9ICR7cmVxdWVzdGVySWR9XG4gICAgYFxuICAgIGlmIChleGlzdGluZ01lbWJlci5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGEgbWVtYmVyIG9mIHRoaXMgZ3JvdXAgY2hhdFwiKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIHBlbmRpbmcgcmVxdWVzdFxuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBpZCBGUk9NIGdyb3VwX2pvaW5fcmVxdWVzdHMgXG4gICAgICBXSEVSRSBncm91cF9jaGF0X2lkID0gJHtncm91cENoYXRJZH0gQU5EIHJlcXVlc3Rlcl9pZCA9ICR7cmVxdWVzdGVySWR9XG4gICAgYFxuICAgIGlmIChleGlzdGluZ1JlcXVlc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSm9pbiByZXF1ZXN0IGFscmVhZHkgcGVuZGluZ1wiKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIGdyb3VwX2pvaW5fcmVxdWVzdHMgKGdyb3VwX2NoYXRfaWQsIHJlcXVlc3Rlcl9pZCwgc3RhdHVzKVxuICAgICAgVkFMVUVTICgke2dyb3VwQ2hhdElkfSwgJHtyZXF1ZXN0ZXJJZH0sICdwZW5kaW5nJylcbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gY3JlYXRlSm9pblJlcXVlc3QgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZW5kaW5nSm9pblJlcXVlc3RzKGdyb3VwQ2hhdElkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgZ2pyLiosIHUudXNlcm5hbWUsIHUubmFtZV9jb2xvciwgdS5jdXN0b21fdGl0bGUsIHUuaGFzX2dvbGRfYW5pbWF0aW9uXG4gICAgICBGUk9NIGdyb3VwX2pvaW5fcmVxdWVzdHMgZ2pyXG4gICAgICBKT0lOIHVzZXJzIHUgT04gZ2pyLnJlcXVlc3Rlcl9pZCA9IHUuaWRcbiAgICAgIFdIRVJFIGdqci5ncm91cF9jaGF0X2lkID0gJHtncm91cENoYXRJZH0gQU5EIGdqci5zdGF0dXMgPSAncGVuZGluZydcbiAgICAgIE9SREVSIEJZIGdqci5jcmVhdGVkX2F0IEFTQ1xuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGdldFBlbmRpbmdKb2luUmVxdWVzdHMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHByb3ZlSm9pblJlcXVlc3QocmVxdWVzdElkOiBzdHJpbmcsIGdyb3VwQ2hhdElkOiBzdHJpbmcsIHJlcXVlc3RlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzcWxgQkVHSU5gXG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSByZXF1ZXN0IHN0YXR1c1xuICAgIGF3YWl0IHNxbGBcbiAgICAgIFVQREFURSBncm91cF9qb2luX3JlcXVlc3RzIFxuICAgICAgU0VUIHN0YXR1cyA9ICdhcHByb3ZlZCcsIHVwZGF0ZWRfYXQgPSBOT1coKVxuICAgICAgV0hFUkUgaWQgPSAke3JlcXVlc3RJZH1cbiAgICBgXG4gICAgXG4gICAgLy8gQWRkIHVzZXIgdG8gZ3JvdXAgY2hhdCBtZW1iZXJzXG4gICAgYXdhaXQgc3FsYFxuICAgICAgSU5TRVJUIElOVE8gZ3JvdXBfY2hhdF9tZW1iZXJzIChncm91cF9jaGF0X2lkLCB1c2VyX2lkKVxuICAgICAgVkFMVUVTICgke2dyb3VwQ2hhdElkfSwgJHtyZXF1ZXN0ZXJJZH0pXG4gICAgICBPTiBDT05GTElDVCAoZ3JvdXBfY2hhdF9pZCwgdXNlcl9pZCkgRE8gTk9USElOR1xuICAgIGBcbiAgICBcbiAgICBhd2FpdCBzcWxgQ09NTUlUYFxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGF3YWl0IHNxbGBST0xMQkFDS2BcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBhcHByb3ZlSm9pblJlcXVlc3QgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWplY3RKb2luUmVxdWVzdChyZXF1ZXN0SWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFVQREFURSBncm91cF9qb2luX3JlcXVlc3RzIFxuICAgICAgU0VUIHN0YXR1cyA9ICdyZWplY3RlZCcsIHVwZGF0ZWRfYXQgPSBOT1coKVxuICAgICAgV0hFUkUgaWQgPSAke3JlcXVlc3RJZH1cbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gcmVqZWN0Sm9pblJlcXVlc3QgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVHcm91cENoYXQoZ3JvdXBJZDogc3RyaW5nLCBjcmVhdG9ySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IGNoYXQgPSBhd2FpdCBzcWxgU0VMRUNUIGNyZWF0b3JfaWQgRlJPTSBncm91cF9jaGF0cyBXSEVSRSBpZCA9ICR7Z3JvdXBJZH1gXG4gICAgaWYgKCFjaGF0WzBdIHx8IGNoYXRbMF0uY3JlYXRvcl9pZCAhPT0gY3JlYXRvcklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgdG8gZGVsZXRlIHRoaXMgZ3JvdXAgY2hhdC5cIilcbiAgICB9XG5cbiAgICBhd2FpdCBzcWxgQkVHSU5gXG4gICAgYXdhaXQgc3FsYERFTEVURSBGUk9NIG1lc3NhZ2VzIFdIRVJFIGNoYXRfdHlwZSA9ICdncm91cCcgQU5EIGNoYXRfaWQgPSAke2dyb3VwSWR9YFxuICAgIGF3YWl0IHNxbGBERUxFVEUgRlJPTSBncm91cF9jaGF0X21lbWJlcnMgV0hFUkUgZ3JvdXBfY2hhdF9pZCA9ICR7Z3JvdXBJZH1gXG4gICAgYXdhaXQgc3FsYERFTEVURSBGUk9NIGdyb3VwX2NoYXRzIFdIRVJFIGlkID0gJHtncm91cElkfWBcbiAgICBhd2FpdCBzcWxgQ09NTUlUYFxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYXdhaXQgc3FsYFJPTExCQUNLYFxuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGRlbGV0ZUdyb3VwQ2hhdCBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZyaWVuZHNoaXAocmVxdWVzdGVySWQ6IHN0cmluZywgYWRkcmVzc2VlSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGlmIChyZXF1ZXN0ZXJJZCA9PT0gYWRkcmVzc2VlSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZW5kIGZyaWVuZCByZXF1ZXN0IHRvIHlvdXJzZWxmLlwiKVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgc3FsYFxuICAgICAgU0VMRUNUICogRlJPTSBmcmllbmRzaGlwc1xuICAgICAgV0hFUkUgKHJlcXVlc3Rlcl9pZCA9ICR7cmVxdWVzdGVySWR9IEFORCBhZGRyZXNzZWVfaWQgPSAke2FkZHJlc3NlZUlkfSlcbiAgICAgICAgIE9SIChyZXF1ZXN0ZXJfaWQgPSAke2FkZHJlc3NlZUlkfSBBTkQgYWRkcmVzc2VlX2lkID0gJHtyZXF1ZXN0ZXJJZH0pXG4gICAgICBMSU1JVCAxXG4gICAgYFxuXG4gICAgaWYgKGV4aXN0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChleGlzdGluZ1swXS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyaWVuZCByZXF1ZXN0IGFscmVhZHkgcGVuZGluZy5cIilcbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdbMF0uc3RhdHVzID09PSBcImFjY2VwdGVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBmcmllbmRzIHdpdGggdGhpcyB1c2VyLlwiKVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1swXS5zdGF0dXMgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZW5kIHJlcXVlc3QgZHVlIHRvIGV4aXN0aW5nIGJsb2NrLlwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIGZyaWVuZHNoaXBzIChyZXF1ZXN0ZXJfaWQsIGFkZHJlc3NlZV9pZCwgc3RhdHVzKVxuICAgICAgVkFMVUVTICgke3JlcXVlc3RlcklkfSwgJHthZGRyZXNzZWVJZH0sICdwZW5kaW5nJylcbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gY3JlYXRlRnJpZW5kc2hpcCBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZyaWVuZHNoaXBTdGF0dXMoZnJpZW5kc2hpcElkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgVVBEQVRFIGZyaWVuZHNoaXBzIFxuICAgICAgU0VUIHN0YXR1cyA9ICR7c3RhdHVzfSwgdXBkYXRlZF9hdCA9IE5PVygpXG4gICAgICBXSEVSRSBpZCA9ICR7ZnJpZW5kc2hpcElkfVxuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSB1cGRhdGVGcmllbmRzaGlwU3RhdHVzIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RnJpZW5kc2hpcHModXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgZi4qLCBcbiAgICAgICAgICAgICB1MS51c2VybmFtZSBhcyByZXF1ZXN0ZXJfdXNlcm5hbWUsXG4gICAgICAgICAgICAgdTIudXNlcm5hbWUgYXMgYWRkcmVzc2VlX3VzZXJuYW1lLFxuICAgICAgICAgICAgIHUxLm5hbWVfY29sb3IgYXMgcmVxdWVzdGVyX25hbWVfY29sb3IsXG4gICAgICAgICAgICAgdTIubmFtZV9jb2xvciBhcyBhZGRyZXNzZWVfbmFtZV9jb2xvcixcbiAgICAgICAgICAgICB1MS5oYXNfZ29sZF9hbmltYXRpb24gYXMgcmVxdWVzdGVyX2hhc19nb2xkLFxuICAgICAgICAgICAgIHUyLmhhc19nb2xkX2FuaW1hdGlvbiBhcyBhZGRyZXNzZWVfaGFzX2dvbGRcbiAgICAgIEZST00gZnJpZW5kc2hpcHMgZlxuICAgICAgSk9JTiB1c2VycyB1MSBPTiBmLnJlcXVlc3Rlcl9pZCA9IHUxLmlkXG4gICAgICBKT0lOIHVzZXJzIHUyIE9OIGYuYWRkcmVzc2VlX2lkID0gdTIuaWRcbiAgICAgIFdIRVJFIChmLnJlcXVlc3Rlcl9pZCA9ICR7dXNlcklkfSBPUiBmLmFkZHJlc3NlZV9pZCA9ICR7dXNlcklkfSlcbiAgICAgIE9SREVSIEJZIGYuY3JlYXRlZF9hdCBERVNDXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0RnJpZW5kc2hpcHMgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2NlcHRlZEZyaWVuZHModXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgRElTVElOQ1RcbiAgICAgICAgQ0FTRSBcbiAgICAgICAgICBXSEVOIGYucmVxdWVzdGVyX2lkID0gJHt1c2VySWR9IFRIRU4gdTIuaWRcbiAgICAgICAgICBFTFNFIHUxLmlkXG4gICAgICAgIEVORCBhcyBmcmllbmRfaWQsXG4gICAgICAgIENBU0UgXG4gICAgICAgICAgV0hFTiBmLnJlcXVlc3Rlcl9pZCA9ICR7dXNlcklkfSBUSEVOIHUyLnVzZXJuYW1lXG4gICAgICAgICAgRUxTRSB1MS51c2VybmFtZVxuICAgICAgICBFTkQgYXMgZnJpZW5kX3VzZXJuYW1lLFxuICAgICAgICBDQVNFIFxuICAgICAgICAgIFdIRU4gZi5yZXF1ZXN0ZXJfaWQgPSAke3VzZXJJZH0gVEhFTiB1Mi5uYW1lX2NvbG9yXG4gICAgICAgICAgRUxTRSB1MS5uYW1lX2NvbG9yXG4gICAgICAgIEVORCBhcyBmcmllbmRfbmFtZV9jb2xvcixcbiAgICAgICAgQ0FTRSBcbiAgICAgICAgICBXSEVOIGYucmVxdWVzdGVyX2lkID0gJHt1c2VySWR9IFRIRU4gdTIuaGFzX2dvbGRfYW5pbWF0aW9uXG4gICAgICAgICAgRUxTRSB1MS5oYXNfZ29sZF9hbmltYXRpb25cbiAgICAgICAgRU5EIGFzIGZyaWVuZF9oYXNfZ29sZFxuICAgICAgRlJPTSBmcmllbmRzaGlwcyBmXG4gICAgICBKT0lOIHVzZXJzIHUxIE9OIGYucmVxdWVzdGVyX2lkID0gdTEuaWRcbiAgICAgIEpPSU4gdXNlcnMgdTIgT04gZi5hZGRyZXNzZWVfaWQgPSB1Mi5pZFxuICAgICAgV0hFUkUgKGYucmVxdWVzdGVyX2lkID0gJHt1c2VySWR9IE9SIGYuYWRkcmVzc2VlX2lkID0gJHt1c2VySWR9KVxuICAgICAgQU5EIGYuc3RhdHVzID0gJ2FjY2VwdGVkJ1xuICAgICAgT1JERVIgQlkgZnJpZW5kX3VzZXJuYW1lXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0QWNjZXB0ZWRGcmllbmRzIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckRNcyh1c2VySWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFNFTEVDVCBESVNUSU5DVFxuICAgICAgICBDQVNFXG4gICAgICAgICAgV0hFTiBtLnNlbmRlcl9pZCA9ICR7dXNlcklkfSBUSEVOIG0uY2hhdF9pZFxuICAgICAgICAgIEVMU0UgbS5zZW5kZXJfaWRcbiAgICAgICAgRU5EIGFzIGZyaWVuZF9pZCxcbiAgICAgICAgdS51c2VybmFtZSBhcyBmcmllbmRfdXNlcm5hbWUsXG4gICAgICAgIHUubmFtZV9jb2xvciBhcyBmcmllbmRfbmFtZV9jb2xvcixcbiAgICAgICAgdS5oYXNfZ29sZF9hbmltYXRpb24gYXMgZnJpZW5kX2hhc19nb2xkLFxuICAgICAgICBNQVgobS5jcmVhdGVkX2F0KSBhcyBsYXN0X21lc3NhZ2VfYXRcbiAgICAgIEZST00gbWVzc2FnZXMgbVxuICAgICAgSk9JTiB1c2VycyB1IE9OIFxuICAgICAgICBDQVNFXG4gICAgICAgICAgV0hFTiBtLnNlbmRlcl9pZCA9ICR7dXNlcklkfSBUSEVOIG0uY2hhdF9pZFxuICAgICAgICAgIEVMU0UgbS5zZW5kZXJfaWRcbiAgICAgICAgRU5EID0gdS5pZFxuICAgICAgV0hFUkUgbS5jaGF0X3R5cGUgPSAnZG0nIFxuICAgICAgQU5EIChtLnNlbmRlcl9pZCA9ICR7dXNlcklkfSBPUiBtLmNoYXRfaWQgPSAke3VzZXJJZH0pXG4gICAgICBBTkQgdS5pZCAhPSAke3VzZXJJZH1cbiAgICAgIEFORCB1LmlkICE9ICR7QUlfVVNFUl9JRH1cbiAgICAgIEdST1VQIEJZIGZyaWVuZF9pZCwgdS51c2VybmFtZSwgdS5uYW1lX2NvbG9yLCB1Lmhhc19nb2xkX2FuaW1hdGlvblxuICAgICAgT1JERVIgQlkgbGFzdF9tZXNzYWdlX2F0IERFU0NcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBnZXRVc2VyRE1zIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdGl0bGU6IHN0cmluZyxcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBjaGF0VHlwZT86IHN0cmluZyxcbiAgY2hhdElkPzogc3RyaW5nLFxuICBzZW5kZXJVc2VybmFtZT86IHN0cmluZyxcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIElOU0VSVCBJTlRPIG5vdGlmaWNhdGlvbnMgKHVzZXJfaWQsIHRpdGxlLCBtZXNzYWdlLCBjaGF0X3R5cGUsIGNoYXRfaWQsIHNlbmRlcl91c2VybmFtZSlcbiAgICAgIFZBTFVFUyAoJHt1c2VySWR9LCAke3RpdGxlfSwgJHttZXNzYWdlfSwgJHtjaGF0VHlwZX0sICR7Y2hhdElkfSwgJHtzZW5kZXJVc2VybmFtZX0pXG4gICAgICBSRVRVUk5JTkcgKlxuICAgIGBcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGJdIGNyZWF0ZU5vdGlmaWNhdGlvbiBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVucmVhZE5vdGlmaWNhdGlvbnModXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBTRUxFQ1QgKiBGUk9NIG5vdGlmaWNhdGlvbnNcbiAgICAgIFdIRVJFIHVzZXJfaWQgPSAke3VzZXJJZH0gQU5EIGlzX3JlYWQgPSBGQUxTRVxuICAgICAgT1JERVIgQlkgY3JlYXRlZF9hdCBERVNDXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcmtOb3RpZmljYXRpb25Bc1JlYWQobm90aWZpY2F0aW9uSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBVUERBVEUgbm90aWZpY2F0aW9uc1xuICAgICAgU0VUIGlzX3JlYWQgPSBUUlVFLCBjcmVhdGVkX2F0ID0gTk9XKClcbiAgICAgIFdIRVJFIGlkID0gJHtub3RpZmljYXRpb25JZH0gQU5EIHVzZXJfaWQgPSAke3VzZXJJZH1cbiAgICAgIFJFVFVSTklORyAqXG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gbWFya05vdGlmaWNhdGlvbkFzUmVhZCBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZE1lc3NhZ2VSZWFjdGlvbihtZXNzYWdlSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIGVtb2ppOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxgXG4gICAgICBJTlNFUlQgSU5UTyBtZXNzYWdlX3JlYWN0aW9ucyAobWVzc2FnZV9pZCwgdXNlcl9pZCwgZW1vamkpXG4gICAgICBWQUxVRVMgKCR7bWVzc2FnZUlkfSwgJHt1c2VySWR9LCAke2Vtb2ppfSlcbiAgICAgIE9OIENPTkZMSUNUIChtZXNzYWdlX2lkLCB1c2VyX2lkLCBlbW9qaSkgRE8gTk9USElOR1xuICAgICAgUkVUVVJOSU5HICpcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBhZGRNZXNzYWdlUmVhY3Rpb24gZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVNZXNzYWdlUmVhY3Rpb24obWVzc2FnZUlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nLCBlbW9qaTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgc3FsYFxuICAgICAgREVMRVRFIEZST00gbWVzc2FnZV9yZWFjdGlvbnNcbiAgICAgIFdIRVJFIG1lc3NhZ2VfaWQgPSAke21lc3NhZ2VJZH1cbiAgICAgICAgQU5EIHVzZXJfaWQgICA9ICR7dXNlcklkfVxuICAgICAgICBBTkQgZW1vamkgICAgID0gJHtlbW9qaX1cbiAgICBgXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gcmVtb3ZlTWVzc2FnZVJlYWN0aW9uIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlclNldHRpbmdzKHVzZXJJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhbGxvd2VkRmllbGRzID0gW1wibmFtZV9jb2xvclwiLCBcIm5vdGlmaWNhdGlvbnNfZW5hYmxlZFwiLCBcInRoZW1lXCIsIFwiaHVlXCIsIFwidWlfbW9kZVwiXVxuICAgIGNvbnN0IHZhbGlkVXBkYXRlczogYW55ID0ge31cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMpKSB7XG4gICAgICBpZiAoYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHZhbGlkVXBkYXRlc1trZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXModmFsaWRVcGRhdGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIGZpZWxkcyB0byB1cGRhdGVcIilcbiAgICB9XG5cbiAgICBjb25zdCBzZXRDbGF1c2UgPSBPYmplY3Qua2V5cyh2YWxpZFVwZGF0ZXMpXG4gICAgICAubWFwKChrZXksIGluZGV4KSA9PiBgJHtrZXl9ID0gJCR7aW5kZXggKyAyfWApXG4gICAgICAuam9pbihcIiwgXCIpXG5cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IGBcbiAgICAgIFVQREFURSB1c2VycyBcbiAgICAgIFNFVCAke3NldENsYXVzZX0sIHVwZGF0ZWRfYXQgPSBOT1coKVxuICAgICAgV0hFUkUgaWQgPSAkMVxuICAgICAgUkVUVVJOSU5HIGlkLCB1c2VybmFtZSwgZW1haWwsIHNpZ251cF9jb2RlLCBuYW1lX2NvbG9yLCBjdXN0b21fdGl0bGUsIGhhc19nb2xkX2FuaW1hdGlvbiwgbm90aWZpY2F0aW9uc19lbmFibGVkLCB0aGVtZSwgaHVlLCBwcm9maWxlX3BpY3R1cmUsIGJpbywgdWlfbW9kZVxuICAgIGBcblxuICAgIGNvbnN0IHBhcmFtcyA9IFt1c2VySWQsIC4uLk9iamVjdC52YWx1ZXModmFsaWRVcGRhdGVzKV1cbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gYXdhaXQgKHNxbCBhcyBhbnkpLnVuc2FmZShxdWVyeVN0cmluZywgcGFyYW1zIGFzIGFueSlcblxuICAgIGlmICghcmVzdWx0IHx8IChyZXN1bHQgYXMgYW55KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIG9yIG5vIHNldHRpbmdzIHVwZGF0ZWQuXCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIChyZXN1bHQgYXMgYW55KVswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSB1cGRhdGVVc2VyU2V0dGluZ3MgZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbi8vIEZyZWV6ZSBmZWF0dXJlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0VXNlckZyb3plbih0YXJnZXRVc2VySWQ6IHN0cmluZywgZnJvemVuQnlVc2VySWQ6IHN0cmluZywgbWVzc2FnZT86IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbGBcbiAgICAgIFVQREFURSB1c2Vyc1xuICAgICAgU0VUIGlzX2Zyb3plbiA9IFRSVUUsIGZyb3plbl9ieSA9ICR7ZnJvemVuQnlVc2VySWR9LCBmcmVlemVfbWVzc2FnZSA9ICR7bWVzc2FnZSB8fCBudWxsfSwgdXBkYXRlZF9hdCA9IE5PVygpXG4gICAgICBXSEVSRSBpZCA9ICR7dGFyZ2V0VXNlcklkfVxuICAgICAgUkVUVVJOSU5HIGlkLCBpc19mcm96ZW4sIGZyb3plbl9ieSwgZnJlZXplX21lc3NhZ2VcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBzZXRVc2VyRnJvemVuIGVycm9yOlwiLCBlcnIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgZXJyb3I6IFwiICsgKGVyciBhcyBFcnJvcikubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJVc2VyRnJvemVuKHRhcmdldFVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgVVBEQVRFIHVzZXJzXG4gICAgICBTRVQgaXNfZnJvemVuID0gRkFMU0UsIGZyb3plbl9ieSA9IE5VTEwsIGZyZWV6ZV9tZXNzYWdlID0gTlVMTCwgdXBkYXRlZF9hdCA9IE5PVygpXG4gICAgICBXSEVSRSBpZCA9ICR7dGFyZ2V0VXNlcklkfVxuICAgICAgUkVUVVJOSU5HIGlkLCBpc19mcm96ZW4sIGZyb3plbl9ieSwgZnJlZXplX21lc3NhZ2VcbiAgICBgXG4gICAgcmV0dXJuIHJlc3VsdFswXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RiXSBjbGVhclVzZXJGcm96ZW4gZXJyb3I6XCIsIGVycilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBlcnJvcjogXCIgKyAoZXJyIGFzIEVycm9yKS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyRnJlZXplU3RhdHVzKHVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsYFxuICAgICAgU0VMRUNUIGlzX2Zyb3plbiwgZnJvemVuX2J5LCBmcmVlemVfbWVzc2FnZSBGUk9NIHVzZXJzIFdIRVJFIGlkID0gJHt1c2VySWR9XG4gICAgYFxuICAgIHJldHVybiByZXN1bHRbMF1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltkYl0gZ2V0VXNlckZyZWV6ZVN0YXR1cyBlcnJvcjpcIiwgZXJyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGVycm9yOiBcIiArIChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJuZW9uIiwiQUlfVVNFUl9JRCIsInNxbCIsInByb2Nlc3MiLCJlbnYiLCJEQVRBQkFTRV9VUkwiLCJxdWVyeSIsImRiIiwiY3JlYXRlVXNlciIsInVzZXJuYW1lIiwicGFzc3dvcmRIYXNoIiwic2lnbnVwQ29kZSIsIm5hbWVDb2xvciIsImN1c3RvbVRpdGxlIiwiaGFzR29sZEFuaW1hdGlvbiIsInJlc3VsdCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImdldFVzZXJCeVVzZXJuYW1lIiwicm93cyIsImdldFVzZXJCeUlkIiwiaWQiLCJ1cGRhdGVVc2VyQWN0aXZpdHkiLCJ1c2VySWQiLCJnZXRPbmxpbmVVc2VycyIsImN1cnJlbnRVc2VySWQiLCJzZWFyY2hVc2VycyIsInNlYXJjaFF1ZXJ5IiwiZ2V0TWVzc2FnZXMiLCJjaGF0VHlwZSIsImNoYXRJZCIsImxpbWl0IiwicmV2ZXJzZSIsImNyZWF0ZU1lc3NhZ2UiLCJzZW5kZXJJZCIsImNvbnRlbnQiLCJtZW50aW9ucyIsImlzQWlSZXNwb25zZSIsInBhcmVudE1lc3NhZ2VJZCIsIm1lc3NhZ2VUeXBlIiwiZ2VuZXJhdGVTaG9ydENvZGUiLCJjaGFycyIsImkiLCJjaGFyQXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJjcmVhdGVHcm91cENoYXQiLCJuYW1lIiwiY3JlYXRvcklkIiwibWVtYmVySWRzIiwic2hvcnRDb2RlIiwiYXR0ZW1wdHMiLCJleGlzdGluZyIsIm1lbWJlcklkIiwiZ2V0VXNlckdyb3VwQ2hhdHMiLCJnZXRHcm91cENoYXRCeVNob3J0Q29kZSIsImNyZWF0ZUpvaW5SZXF1ZXN0IiwiZ3JvdXBDaGF0SWQiLCJyZXF1ZXN0ZXJJZCIsImV4aXN0aW5nTWVtYmVyIiwiZXhpc3RpbmdSZXF1ZXN0IiwiZ2V0UGVuZGluZ0pvaW5SZXF1ZXN0cyIsImFwcHJvdmVKb2luUmVxdWVzdCIsInJlcXVlc3RJZCIsInJlamVjdEpvaW5SZXF1ZXN0IiwiZGVsZXRlR3JvdXBDaGF0IiwiZ3JvdXBJZCIsImNoYXQiLCJjcmVhdG9yX2lkIiwiY3JlYXRlRnJpZW5kc2hpcCIsImFkZHJlc3NlZUlkIiwic3RhdHVzIiwidXBkYXRlRnJpZW5kc2hpcFN0YXR1cyIsImZyaWVuZHNoaXBJZCIsImdldEZyaWVuZHNoaXBzIiwiZ2V0QWNjZXB0ZWRGcmllbmRzIiwiZ2V0VXNlckRNcyIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsInRpdGxlIiwic2VuZGVyVXNlcm5hbWUiLCJnZXRVbnJlYWROb3RpZmljYXRpb25zIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsIm5vdGlmaWNhdGlvbklkIiwiYWRkTWVzc2FnZVJlYWN0aW9uIiwibWVzc2FnZUlkIiwiZW1vamkiLCJyZW1vdmVNZXNzYWdlUmVhY3Rpb24iLCJ1cGRhdGVVc2VyU2V0dGluZ3MiLCJ1cGRhdGVzIiwiYWxsb3dlZEZpZWxkcyIsInZhbGlkVXBkYXRlcyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImluY2x1ZGVzIiwia2V5cyIsInNldENsYXVzZSIsIm1hcCIsImluZGV4Iiwiam9pbiIsInF1ZXJ5U3RyaW5nIiwicGFyYW1zIiwidmFsdWVzIiwidW5zYWZlIiwic2V0VXNlckZyb3plbiIsInRhcmdldFVzZXJJZCIsImZyb3plbkJ5VXNlcklkIiwiY2xlYXJVc2VyRnJvemVuIiwiZ2V0VXNlckZyZWV6ZVN0YXR1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./lib/db.ts\n");

/***/ })

});